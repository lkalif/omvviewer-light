Index: Permissions.cs
===================================================================
--- Permissions.cs	(revision 2457)
+++ Permissions.cs	(working copy)
@@ -73,6 +73,7 @@
     /// <summary>
     /// 
     /// </summary>
+    [Serializable()]
     public struct Permissions
     {
         public PermissionMask BaseMask;
Index: InventoryManager.cs
===================================================================
--- InventoryManager.cs	(revision 2457)
+++ InventoryManager.cs	(working copy)
@@ -29,6 +29,7 @@
 using System.Text.RegularExpressions;
 using System.Threading;
 using System.Text;
+using System.Runtime.Serialization;
 using OpenMetaverse.Http;
 using OpenMetaverse.StructuredData;
 using OpenMetaverse.Packets;
@@ -159,7 +160,8 @@
     /// <summary>
     /// Base Class for Inventory Items
     /// </summary>
-    public abstract class InventoryBase
+    [Serializable()]
+    public abstract class InventoryBase : ISerializable
     {
         /// <summary><seealso cref="OpenMetaverse.UUID"/> of item/folder</summary>
         public readonly UUID UUID;
@@ -182,6 +184,30 @@
         }
 
         /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public void GetObjectData(SerializationInfo info, StreamingContext ctxt)
+        {
+            info.AddValue("UUID", UUID);
+            info.AddValue("ParentUUID",ParentUUID );
+            info.AddValue("Name", Name);
+            info.AddValue("OwnerID", OwnerID);
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public InventoryBase(SerializationInfo info, StreamingContext ctxt)
+        {
+            UUID = (UUID)info.GetValue("UUID", typeof(UUID));
+            ParentUUID = (UUID)info.GetValue("ParentUUID", typeof(UUID));
+            Name = (string)info.GetValue("Name", typeof(string));
+            OwnerID = (UUID)info.GetValue("OwnerID", typeof(UUID));
+        }
+
+        /// <summary>
         /// Generates a number corresponding to the value of the object to support the use of a hash table,
         /// suitable for use in hashing algorithms and data structures such as a hash table
         /// </summary>
@@ -261,7 +287,49 @@
         /// <param name="itemID"><seealso cref="OpenMetaverse.UUID"/> of the item</param>
         public InventoryItem(InventoryType type, UUID itemID) : base(itemID) { InventoryType = type; }
 
+
         /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        new public void GetObjectData(SerializationInfo info, StreamingContext ctxt) 
+        {
+            base.GetObjectData(info,ctxt);
+            info.AddValue("AssetUUID",AssetUUID,typeof(UUID));
+            info.AddValue("Permissions", Permissions,typeof(Permissions));
+            info.AddValue("AssetType", AssetType);
+            info.AddValue("InventoryType", InventoryType);
+            info.AddValue("CreatorID", CreatorID);
+            info.AddValue("Description", Description);
+            info.AddValue("GroupID", GroupID);
+            info.AddValue("GroupOwned", GroupOwned);
+            info.AddValue("SalePrice", SalePrice);
+            info.AddValue("SaleType", SaleType);
+            info.AddValue("Flags", Flags);
+            info.AddValue("CreationDate", CreationDate);  
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public InventoryItem(SerializationInfo info, StreamingContext ctxt) : base (info,ctxt)
+        {
+           AssetUUID = (UUID)info.GetValue("AssetUUID", typeof(UUID));
+           Permissions =(Permissions)info.GetValue("Permissions",typeof(Permissions));
+           AssetType = (AssetType)info.GetValue("AssetType", typeof(AssetType));
+           InventoryType = (InventoryType)info.GetValue("InventoryType", typeof(InventoryType));
+           CreatorID = (UUID)info.GetValue("CreatorID", typeof(UUID));
+           Description = (string)info.GetValue("Description", typeof(string));
+           GroupID= (UUID)info.GetValue("GroupID", typeof(UUID));
+           GroupOwned = (bool)info.GetValue("GroupOwned", typeof(bool));
+           SalePrice = (int)info.GetValue("SalePrice", typeof(int));
+           SaleType = (SaleType)info.GetValue("SaleType", typeof(SaleType));
+           Flags = (uint)info.GetValue("Flags", typeof(uint));
+           CreationDate = (DateTime)info.GetValue("CreationDate", typeof(DateTime));
+        }
+
+        /// <summary>
         /// Generates a number corresponding to the value of the object to support the use of a hash table.
         /// Suitable for use in hashing algorithms and data structures such as a hash table
         /// </summary>
@@ -333,6 +401,11 @@
         { 
             InventoryType = InventoryType.Texture; 
         } 
+
+        public InventoryTexture(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Texture; 
+        }
     }
 
     /// <summary>
@@ -349,6 +422,11 @@
         { 
             InventoryType = InventoryType.Sound; 
         } 
+
+        public InventorySound(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Sound; 
+        }
     }
 
     /// <summary>
@@ -365,6 +443,10 @@
         { 
             InventoryType = InventoryType.CallingCard; 
         }
+        public InventoryCallingCard(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.CallingCard; 
+        }
     }
 
     /// <summary>
@@ -382,6 +464,12 @@
             InventoryType = InventoryType.Landmark; 
         }
 
+        public InventoryLandmark(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Landmark;
+
+        }
+
         /// <summary>
         /// Landmarks use the ObjectType struct and will have a flag of 1 set if they have been visited
         /// </summary>
@@ -407,6 +495,11 @@
             InventoryType = InventoryType.Object; 
         }
 
+        public InventoryObject(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Object; 
+        }
+
         /// <summary>
         /// Get the Objects permission override settings
         /// 
@@ -433,7 +526,11 @@
         public InventoryNotecard(UUID itemID) : base(itemID) 
         { 
             InventoryType = InventoryType.Notecard; 
-        } 
+        }
+        public InventoryNotecard(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Notecard; 
+        }
     }
 
     /// <summary>
@@ -451,6 +548,11 @@
         { 
             InventoryType = InventoryType.Category; 
         } 
+
+        public InventoryCategory(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Category; 
+        }
     }
 
     /// <summary>
@@ -467,6 +569,11 @@
         { 
             InventoryType = InventoryType.LSL; 
         } 
+
+        public InventoryLSL(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.LSL; 
+        }
     }
 
     /// <summary>
@@ -483,6 +590,11 @@
         { 
             InventoryType = InventoryType.Snapshot; 
         } 
+
+        public InventorySnapshot(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Snapshot; 
+        }
     }
 
     /// <summary>
@@ -500,6 +612,11 @@
             InventoryType = InventoryType.Attachment; 
         }
 
+        public InventoryAttachment(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Attachment; 
+        }
+
         /// <summary>
         /// Get the last AttachmentPoint this object was attached to
         /// </summary>
@@ -522,6 +639,11 @@
         /// <seealso cref="OpenMetaverse.InventoryItem"/> objects AssetUUID</param>
         public InventoryWearable(UUID itemID) : base(itemID) { InventoryType = InventoryType.Wearable; }
 
+        public InventoryWearable(SerializationInfo info, StreamingContext ctxt) : base(info, ctxt)
+        {
+            InventoryType = InventoryType.Wearable; 
+        }
+
         /// <summary>
         /// The <seealso cref="OpenMetaverse.WearableType"/>, Skin, Shape, Skirt, Etc
         /// </summary>
@@ -545,7 +667,14 @@
         public InventoryAnimation(UUID itemID) : base(itemID) 
         { 
             InventoryType = InventoryType.Animation; 
-        } 
+        }
+
+        public InventoryAnimation(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Animation; 
+        }
+ 
+
     }
 
     /// <summary>
@@ -562,6 +691,11 @@
         { 
             InventoryType = InventoryType.Gesture; 
         } 
+
+        public InventoryGesture(SerializationInfo info, StreamingContext ctxt): base(info, ctxt)
+        {
+            InventoryType = InventoryType.Gesture; 
+        }
     }
     
     /// <summary>
@@ -597,6 +731,30 @@
         /// 
         /// </summary>
         /// <returns></returns>
+        new public void GetObjectData(SerializationInfo info, StreamingContext ctxt)
+        {
+            base.GetObjectData(info,ctxt);
+            info.AddValue("PreferredType", PreferredType, typeof(AssetType));
+            info.AddValue("Version", Version);
+            info.AddValue("DescendentCount", DescendentCount);
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public InventoryFolder(SerializationInfo info, StreamingContext ctxt) : base (info, ctxt)
+        {
+            PreferredType = (AssetType)info.GetValue("PreferredType", typeof(AssetType));
+            Version=(int)info.GetValue("Version",typeof(int));
+            DescendentCount = (int)info.GetValue("DescendentCount", typeof(int));
+        }
+
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
         public override int GetHashCode()
         {
             return PreferredType.GetHashCode() ^ Version.GetHashCode() ^ DescendentCount.GetHashCode();
Index: Inventory.cs
===================================================================
--- Inventory.cs	(revision 2457)
+++ Inventory.cs	(working copy)
@@ -26,6 +26,9 @@
 
 using System;
 using System.Collections.Generic;
+using System.IO;
+using System.Runtime.Serialization.Formatters.Binary;
+using System.Runtime.Serialization;
 
 namespace OpenMetaverse
 {
@@ -308,6 +311,103 @@
             return Contains(obj.UUID);
         }
 
+        /// <summary>
+        /// Save the current inventory structure to a cache file
+        /// </summary>
+        /// <param name="filename">Name of the cache file to save to</param>
+        public void cache_inventory_to_disk(string filename)
+        {
+            Stream stream = File.Open(filename, FileMode.Create);
+            BinaryFormatter bformatter = new BinaryFormatter();
+            Console.WriteLine("Writing Inventory Information");
+            foreach (KeyValuePair<UUID, InventoryNode> kvp in Items)
+            {
+                bformatter.Serialize(stream, kvp.Value);
+            }
+            stream.Close();
+        }
+
+        /// <summary>
+        /// Loads in inventory cache file into the inventory structure. Note only valid to call after login has been successful.
+        /// </summary>
+        /// <param name="filename">Name of the cache file to load</param>
+        public void read_inventory_cache(string filename)
+        {
+            List<InventoryNode> nodes = new List<InventoryNode>();
+            int item_count = 0;
+
+            try
+            {
+                if (!File.Exists(filename))
+                    return;
+
+                Stream stream = File.Open(filename, FileMode.Open);
+                BinaryFormatter bformatter = new BinaryFormatter();
+
+                while (stream.Position < stream.Length)
+                {
+                    OpenMetaverse.InventoryNode node = (InventoryNode)bformatter.Deserialize(stream);
+                    nodes.Add(node);
+                    item_count++;
+                }
+
+                stream.Close();
+            }
+            catch (Exception e)
+            {
+                Logger.Log("Error accessing inventory cache file :" + e.Message, Helpers.LogLevel.Error);
+                return;
+            }
+
+            Logger.Log("Read " + item_count.ToString() + " items from inventory cache file", Helpers.LogLevel.Info);
+
+            item_count = 0;
+
+            List<InventoryNode> del_nodes = new List<InventoryNode>();
+
+            // Becuase we could get child nodes before parents we must itterate around and only add nodes who have
+            // a parent already in the list because we must update both child and parent to link together
+            while (nodes.Count != 0)
+            {
+                foreach (InventoryNode node in nodes)
+                {
+                    InventoryNode pnode;
+                    if (node.ParentID == UUID.Zero)
+                    {
+                        //We don't need the root nodes "My Inventory" etc as they will already exist for the correct
+                        // user of this cache.
+                        del_nodes.Add(node);
+                    }
+                    else if (Items.TryGetValue(node.ParentID, out pnode))
+                    {
+                        if (node.Data != null)
+                        {
+                            //Only add new items, this is most likely to be run at login time before any inventory
+                            //nodes other than the root are populated.
+                            if (!Items.ContainsKey(node.Data.UUID))
+                            {
+                                Items.Add(node.Data.UUID, node);
+                                node.Parent = pnode; //Update this node with its parent
+                                pnode.Nodes.Add(node.Data.UUID, node); // Add to the parents child list
+                                item_count++;
+                            }
+                        }
+
+                        del_nodes.Add(node);
+                    }
+
+                }
+
+                //Clean up processed nodes this loop around.
+                foreach (InventoryNode node in del_nodes)
+                    nodes.Remove(node);
+
+                del_nodes.Clear();
+            }
+
+            Logger.Log("Reassembled " + item_count.ToString() + " items from inventory cache file", Helpers.LogLevel.Info);
+        }
+
         #region Operators
 
         /// <summary>
Index: InventoryNode.cs
===================================================================
--- InventoryNode.cs	(revision 2457)
+++ InventoryNode.cs	(working copy)
@@ -27,13 +27,16 @@
 using System;
 using System.Collections.Generic;
 using System.Text;
+using System.Runtime.Serialization;
 
 namespace OpenMetaverse
 {
-    public class InventoryNode
+    [Serializable()]
+    public class InventoryNode : ISerializable
     {
         private InventoryBase data;
         private InventoryNode parent;
+        private UUID parentID; //used for de-seralization 
         private InventoryNodeDictionary nodes;
 
         /// <summary></summary>
@@ -51,6 +54,12 @@
         }
 
         /// <summary></summary>
+        public UUID ParentID
+        {
+            get { return parentID; }
+        }
+
+        /// <summary></summary>
         public InventoryNodeDictionary Nodes
         {
             get
@@ -79,6 +88,9 @@
             this.data = data;
         }
 
+        /// <summary>
+        /// De-serialization constructor for the InventoryNode Class
+        /// </summary>
         public InventoryNode(InventoryBase data, InventoryNode parent)
         {
             this.data = data;
@@ -92,9 +104,100 @@
         }
 
         /// <summary>
+        /// Serialization handler for the InventoryNode Class
+        /// </summary>
+        public void GetObjectData(SerializationInfo info, StreamingContext ctxt)
+        {
+            if(parent!=null)
+                info.AddValue("Parent", parent.Data.UUID, typeof(UUID)); //We need to track the parent UUID for de-serialization
+            else
+                info.AddValue("Parent", UUID.Zero, typeof(UUID));
+
+            info.AddValue("Type", data.GetType(), typeof(Type));
+            
+            if(data is InventoryAnimation)
+                ((InventoryAnimation)data).GetObjectData(info, ctxt);
+            if(data is InventoryAttachment)
+                ((InventoryAttachment)data).GetObjectData(info, ctxt);
+            if(data is InventoryCallingCard)
+                ((InventoryCallingCard)data).GetObjectData(info, ctxt);
+            if(data is InventoryFolder)
+                ((InventoryFolder)data).GetObjectData(info, ctxt);
+            if(data is InventoryGesture)
+                ((InventoryGesture)data).GetObjectData(info, ctxt);
+            if(data is InventoryLandmark)
+                ((InventoryLandmark)data).GetObjectData(info, ctxt);
+            if(data is InventoryLSL)
+                ((InventoryLSL)data).GetObjectData(info, ctxt);
+            if (data is InventoryNotecard)
+                ((InventoryNotecard)data).GetObjectData(info, ctxt);
+            if(data is InventoryObject)
+                ((InventoryObject)data).GetObjectData(info, ctxt);
+            if(data is InventorySnapshot)
+                ((InventorySnapshot)data).GetObjectData(info, ctxt);
+            if(data is InventorySound)
+                ((InventorySound)data).GetObjectData(info, ctxt);
+            if (data is InventoryTexture)
+                ((InventoryTexture)data).GetObjectData(info, ctxt);
+            if(data is InventoryWearable)
+                ((InventoryWearable)data).GetObjectData(info, ctxt);
+
+            
+        }
+
+        /// <summary>
         /// 
         /// </summary>
         /// <returns></returns>
+        public InventoryNode(SerializationInfo info, StreamingContext ctxt)
+        {
+            parentID = (UUID)info.GetValue("Parent", typeof(UUID));
+            Type type = (Type)info.GetValue("Type", typeof(Type));
+           
+            if (type == typeof(InventoryAnimation))
+                data = new InventoryAnimation(info, ctxt);
+
+            if (type == typeof(InventoryAttachment))
+                data = new InventoryAttachment(info, ctxt);
+
+            if (type == typeof(InventoryCallingCard))
+                data = new InventoryCallingCard(info, ctxt);
+
+            if (type == typeof(InventoryFolder))
+                data = new InventoryFolder(info, ctxt);
+
+            if (type == typeof(InventoryGesture))
+                data = new InventoryGesture(info, ctxt);
+
+            if (type == typeof(InventoryLandmark))
+                data = new InventoryLandmark(info, ctxt);
+
+            if (type == typeof(InventoryLSL))
+                data = new InventoryLSL(info, ctxt);
+
+            if (type == typeof(InventoryNotecard))
+                data = new InventoryNotecard(info, ctxt);
+
+            if (type == typeof(InventoryObject))
+                data = new InventoryObject(info, ctxt);
+
+            if (type == typeof(InventorySnapshot))
+                data = new InventorySnapshot(info, ctxt);
+
+            if (type == typeof(InventorySound))
+                data = new InventorySound(info, ctxt);
+
+            if (type == typeof(InventoryTexture))
+                data = new InventoryTexture(info, ctxt);
+
+            if (type == typeof(InventoryWearable))
+                data = new InventoryWearable(info, ctxt);
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
         public override string ToString()
         {
             if (this.Data == null) return "[Empty Node]";
Index: Simulator.cs
===================================================================
--- Simulator.cs	(revision 2457)
+++ Simulator.cs	(working copy)
@@ -866,8 +866,8 @@
             // Check if this packet came from the server we expected it to come from
             if (!remoteEndPoint.Address.Equals(((IPEndPoint)buffer.RemoteEndPoint).Address))
             {
-                Logger.Log("Received " + buffer.DataLength + " bytes of data from unrecognized source " +
-                    ((IPEndPoint)buffer.RemoteEndPoint).ToString(), Helpers.LogLevel.Warning, Client);
+               // Logger.Log("Received " + buffer.DataLength + " bytes of data from unrecognized source " +
+                //    ((IPEndPoint)buffer.RemoteEndPoint).ToString(), Helpers.LogLevel.Warning, Client);
                 return;
             }
 
