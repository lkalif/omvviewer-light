Index: AppearanceManager.cs
===================================================================
--- AppearanceManager.cs	(revision 2399)
+++ AppearanceManager.cs	(working copy)
@@ -1,1417 +1,1417 @@
-/*
- * Copyright (c) 2006-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Text;
-using System.Collections.Generic;
-using System.Threading;
-using System.IO;
-using OpenMetaverse;
-using OpenMetaverse.Packets;
-using OpenMetaverse.Imaging;
-
-namespace OpenMetaverse
-{
-    public class InvalidOutfitException : Exception
-    {
-        public InvalidOutfitException(string message) : base(message) { }
-    }
-    
-    /// <summary>
-    /// Manager class to for agents appearance, both body parts and clothing
-    /// </summary>
-    public class AppearanceManager
-    {
-        /// <summary>
-        /// 
-        /// </summary>
-        public enum TextureIndex
-        {
-            Unknown = -1,
-            HeadBodypaint = 0,
-            UpperShirt,
-            LowerPants,
-            EyesIris,
-            Hair,
-            UpperBodypaint,
-            LowerBodypaint,
-            LowerShoes,
-            HeadBaked,
-            UpperBaked,
-            LowerBaked,
-            EyesBaked,
-            LowerSocks,
-            UpperJacket,
-            LowerJacket,
-            UpperGloves,
-            UpperUndershirt,
-            LowerUnderpants,
-            Skirt,
-            SkirtBaked
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        public enum BakeType
-        {
-            Unknown = -1,
-            Head = 0,
-            UpperBody = 1,
-            LowerBody = 2,
-            Eyes = 3,
-            Skirt = 4
-        }
-
-        public class WearableData
-        {
-            public InventoryWearable Item;
-            public AssetWearable Asset;
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        public delegate void AgentWearablesCallback();
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="te"></param>
-        public delegate void AppearanceUpdatedCallback(Primitive.TextureEntry te);
-
-        /// <summary></summary>
-        public event AgentWearablesCallback OnAgentWearables;
-        /// <summary></summary>
-        public event AppearanceUpdatedCallback OnAppearanceUpdated;
-
-        /// <summary>Total number of wearables for each avatar</summary>
-        public const int WEARABLE_COUNT = 13;
-        /// <summary>Total number of baked textures on each avatar</summary>
-        public const int BAKED_TEXTURE_COUNT = 5;
-        /// <summary>Total number of wearables per bake layer</summary>
-        public const int WEARABLES_PER_LAYER = 7;
-        /// <summary>Total number of textures on an avatar, baked or not</summary>
-        public const int AVATAR_TEXTURE_COUNT = 20;
-        /// <summary>Map of what wearables are included in each bake</summary>
-        public static readonly WearableType[][] WEARABLE_BAKE_MAP = new WearableType[][]
-        {
-            new WearableType[] { WearableType.Shape, WearableType.Skin,    WearableType.Hair,    WearableType.Invalid, WearableType.Invalid, WearableType.Invalid,    WearableType.Invalid    },
-            new WearableType[] { WearableType.Shape, WearableType.Skin,    WearableType.Shirt,   WearableType.Jacket,  WearableType.Gloves,  WearableType.Undershirt, WearableType.Invalid    },
-            new WearableType[] { WearableType.Shape, WearableType.Skin,    WearableType.Pants,   WearableType.Shoes,   WearableType.Socks,   WearableType.Jacket,     WearableType.Underpants },
-            new WearableType[] { WearableType.Eyes,  WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid,    WearableType.Invalid    },
-            new WearableType[] { WearableType.Skirt, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid } 
-        };
-        /// <summary>Secret values to finalize the cache check hashes for each
-        /// bake</summary>
-        public static readonly UUID[] BAKED_TEXTURE_HASH = new UUID[]
-        {
-            new UUID("18ded8d6-bcfc-e415-8539-944c0f5ea7a6"),
-	        new UUID("338c29e3-3024-4dbb-998d-7c04cf4fa88f"),
-	        new UUID("91b4a2c7-1b1a-ba16-9a16-1f8f8dcc1c3f"),
-	        new UUID("b2cf28af-b840-1071-3c6a-78085d8128b5"),
-	        new UUID("ea800387-ea1a-14e0-56cb-24f2022f969a")
-        };
-        /// <summary>Default avatar texture, used to detect when a custom
-        /// texture is not set for a face</summary>
-        public static readonly UUID DEFAULT_AVATAR_TEXTURE = new UUID("c228d1cf-4b5d-4ba8-84f4-899a0796aa97");
-
-
-        private GridClient Client;
-        private AssetManager Assets;
-
-        /// <summary>
-        /// An <seealso cref="T:InternalDictionary"/> which keeps track of wearables data
-        /// </summary>
-        public InternalDictionary<WearableType, WearableData> Wearables = new InternalDictionary<WearableType, WearableData>();
-        // As wearable assets are downloaded and decoded, the textures are added to this array
-        private UUID[] AgentTextures = new UUID[AVATAR_TEXTURE_COUNT];
-
-        protected struct PendingAssetDownload
-        {
-            public UUID Id;
-            public AssetType Type;
-
-            public PendingAssetDownload(UUID id, AssetType type)
-            {
-                Id = id;
-                Type = type;
-            }
-        }
-        
-        // Wearable assets are downloaded one at a time, a new request is pulled off the queue
-        // and started when the previous one completes
-        private Queue<PendingAssetDownload> AssetDownloads = new Queue<PendingAssetDownload>();
-        // A list of all the images we are currently downloading, prior to baking
-        private Dictionary<UUID, TextureIndex> ImageDownloads = new Dictionary<UUID, TextureIndex>();
-        // A list of all the bakes we need to complete
-        private Dictionary<BakeType, Baker> PendingBakes = new Dictionary<BakeType, Baker>(BAKED_TEXTURE_COUNT);
-        // A list of all the uploads that are in progress
-        private Dictionary<UUID, TextureIndex> PendingUploads = new Dictionary<UUID, TextureIndex>(BAKED_TEXTURE_COUNT);
-        // Whether the handler for our current wearable list should automatically start downloading the assets
-        //private bool DownloadWearables = false;
-        private static int CacheCheckSerialNum = 1; //FIXME
-        private static uint SetAppearanceSerialNum = 1; //FIXME
-        private WearParams _wearOutfitParams;
-        private bool _bake;
-        private AutoResetEvent WearablesRequestEvent = new AutoResetEvent(false);
-        private AutoResetEvent WearablesDownloadedEvent = new AutoResetEvent(false);
-        private AutoResetEvent CachedResponseEvent = new AutoResetEvent(false);
-        private AutoResetEvent UpdateEvent = new AutoResetEvent(false);
-        // FIXME: Create a class-level appearance thread so multiple threads can't be launched
-
-        /// <summary>
-        /// Default constructor
-        /// </summary>
-        /// <param name="client">This agents <seealso cref="OpenMetaverse.GridClient"/> Object</param>
-        /// <param name="assets">Reference to an AssetManager object</param>
-        public AppearanceManager(GridClient client, AssetManager assets)
-        {
-            Client = client;
-            Assets = assets;
-
-            // Initialize AgentTextures to zero UUIDs
-            for (int i = 0; i < AgentTextures.Length; i++)
-                AgentTextures[i] = UUID.Zero;
-
-            Client.Network.RegisterCallback(PacketType.AgentWearablesUpdate, new NetworkManager.PacketCallback(AgentWearablesUpdateHandler));
-            Client.Network.RegisterCallback(PacketType.AgentCachedTextureResponse, new NetworkManager.PacketCallback(AgentCachedTextureResponseHandler));
-            Client.Network.OnDisconnected += new NetworkManager.DisconnectedCallback(Network_OnDisconnected);
-        }
-
-        private static AssetType WearableTypeToAssetType(WearableType type)
-        {
-            switch (type)
-            {
-                case WearableType.Shape:
-                case WearableType.Skin:
-                case WearableType.Hair:
-                case WearableType.Eyes:
-                    return AssetType.Bodypart;
-                case WearableType.Shirt:
-                case WearableType.Pants:
-                case WearableType.Shoes:
-                case WearableType.Socks:
-                case WearableType.Jacket:
-                case WearableType.Gloves:
-                case WearableType.Undershirt:
-                case WearableType.Underpants:
-                case WearableType.Skirt:
-                    return AssetType.Clothing;
-                default:
-                    throw new Exception("Unhandled wearable type " + type);
-            }
-        }
-
-        /// <summary>
-        /// Returns the assetID for a given WearableType 
-        /// </summary>
-        /// <param name="type">the <seealso cref="OpenMetaverse.WearableType"/> of the asset</param>
-        /// <returns>The <seealso cref="OpenMetaverse.UUID"/> of the WearableType</returns>
-        public UUID GetWearableAsset(WearableType type)
-        {
-            WearableData wearable;
-
-            if (Wearables.TryGetValue(type, out wearable))
-                return wearable.Item.AssetUUID;
-            else
-                return UUID.Zero;
-        }
-
-        /// <summary>
-        /// Ask the server what we are wearing and set appearance based on that
-        /// </summary>
-        public void SetPreviousAppearance()
-        {
-            SetPreviousAppearance(true);
-        }
-
-        public void SetPreviousAppearance(bool bake)
-        {
-            _bake = bake;
-            Thread appearanceThread = new Thread(new ThreadStart(StartSetPreviousAppearance));
-            appearanceThread.Start();
-        }
-
-        private void StartSetPreviousAppearance()
-        {
-            SendAgentWearablesRequest();
-            WearablesRequestEvent.WaitOne();
-            UpdateAppearanceFromWearables(_bake);
-        }
-
-        private class WearParams
-        {
-            public object Param;
-            public bool Bake;
-
-            public WearParams(object param, bool bake)
-            {
-                Param = param;
-                Bake = bake;
-            }
-        }
-
-        /// <summary>
-        /// Replace the current outfit with a list of wearables and set appearance
-        /// </summary>
-        /// <param name="ibs">List of wearables that define the new outfit</param>
-        public void WearOutfit(List<InventoryBase> ibs)
-        {
-            WearOutfit(ibs, true);
-        }
-        
-        /// <summary>
-        /// Replace the current outfit with a list of wearables and set appearance
-        /// </summary>
-        /// <param name="ibs">List of wearables that define the new outfit</param>
-        /// <param name="bake">Whether to bake textures for the avatar or not</param>
-        public void WearOutfit(List<InventoryBase> ibs, bool bake)
-        {
-            _wearParams = new WearParams(ibs, bake);
-            Thread appearanceThread = new Thread(new ThreadStart(StartWearOutfit));
-            appearanceThread.Start();
-        }
-
-        private WearParams _wearParams;
-        private void StartWearOutfit()
-        {
-            List<InventoryBase> ibs = (List<InventoryBase>)_wearParams.Param;
-            List<InventoryWearable> wearables = new List<InventoryWearable>();
-            List<InventoryBase> attachments = new List<InventoryBase>();
-
-            foreach (InventoryBase ib in ibs)
-            {
-                if (ib is InventoryWearable)
-                    wearables.Add((InventoryWearable)ib);
-                else if (ib is InventoryAttachment || ib is InventoryObject)
-                    attachments.Add(ib);
-            }
-
-
-            SendAgentWearablesRequest();
-            WearablesRequestEvent.WaitOne();
-            ReplaceOutfitWearables(wearables);
-            UpdateAppearanceFromWearables(_wearParams.Bake);
-            AddAttachments(attachments, true);
-        }
-
-        /// <summary>
-        /// Replace the current outfit with a folder and set appearance
-        /// </summary>
-        /// <param name="folder">UUID of the inventory folder to wear</param>
-        public void WearOutfit(UUID folder)
-        {
-            WearOutfit(folder, true);
-        }
-
-        /// <summary>
-        /// Replace the current outfit with a folder and set appearance
-        /// </summary>
-        /// <param name="path">Inventory path of the folder to wear</param>
-        public void WearOutfit(string[] path)
-        {
-            WearOutfit(path, true);
-        }
-
-        /// <summary>
-        /// Replace the current outfit with a folder and set appearance
-        /// </summary>
-        /// <param name="folder">Folder containing the new outfit</param>
-        /// <param name="bake">Whether to bake the avatar textures or not</param>
-        public void WearOutfit(UUID folder, bool bake)
-        {
-            _wearOutfitParams = new WearParams(folder, bake);
-            Thread appearanceThread = new Thread(new ThreadStart(StartWearOutfitFolder));
-            appearanceThread.Start();
-        }
-
-        /// <summary>
-        /// Replace the current outfit with a folder and set appearance
-        /// </summary>
-        /// <param name="path">Path of folder containing the new outfit</param>
-        /// <param name="bake">Whether to bake the avatar textures or not</param>
-        public void WearOutfit(string[] path, bool bake)
-        {
-            _wearOutfitParams = new WearParams(path, bake);
-            Thread appearanceThread = new Thread(new ThreadStart(StartWearOutfitFolder));
-            appearanceThread.Start();
-        }
-
-        public void WearOutfit(InventoryFolder folder, bool bake)
-        {
-            _wearOutfitParams = new WearParams(folder, bake);
-            Thread appearanceThread = new Thread(new ThreadStart(StartWearOutfitFolder));
-            appearanceThread.Start();
-        }
-
-        private void StartWearOutfitFolder()
-        {
-            SendAgentWearablesRequest(); // request current wearables async
-            List<InventoryWearable> wearables;
-            List<InventoryBase> attachments;
-
-            if (!GetFolderWearables(_wearOutfitParams.Param, out wearables, out attachments)) // get wearables in outfit folder
-                return; // TODO: this error condition should be passed back to the client somehow
-
-            WearablesRequestEvent.WaitOne(); // wait for current wearables
-            ReplaceOutfitWearables(wearables); // replace current wearables with outfit folder
-            UpdateAppearanceFromWearables(_wearOutfitParams.Bake);
-            AddAttachments(attachments, true);
-        }
-
-        private bool GetFolderWearables(object _folder, out List<InventoryWearable> wearables, out List<InventoryBase> attachments)
-        {
-            UUID folder;
-            wearables = null;
-            attachments = null;
-
-            if (_folder.GetType() == typeof(string[]))
-            {
-                string[] path = (string[])_folder;
-
-                folder = Client.Inventory.FindObjectByPath(
-                    Client.Inventory.Store.RootFolder.UUID, Client.Self.AgentID, String.Join("/", path), 1000 * 20);
-
-                if (folder == UUID.Zero)
-                {
-                    Logger.Log("Outfit path " + path + " not found", Helpers.LogLevel.Error, Client);
-                    return false;
-                }
-            }
-            else
-                folder = (UUID)_folder;
-
-            wearables = new List<InventoryWearable>();
-            attachments = new List<InventoryBase>();
-            List<InventoryBase> objects = Client.Inventory.FolderContents(folder, Client.Self.AgentID,
-                false, true, InventorySortOrder.ByName, 1000 * 20);
-
-            if (objects != null)
-            {
-                foreach (InventoryBase ib in objects)
-                {
-                    if (ib is InventoryWearable)
-                    {
-                        Logger.DebugLog("Adding wearable " + ib.Name, Client);
-                        wearables.Add((InventoryWearable)ib);
-                    }
-                    else if (ib is InventoryAttachment)
-                    {
-                        Logger.DebugLog("Adding attachment (attachment) " + ib.Name, Client);
-                        attachments.Add(ib);
-                    }
-                    else if (ib is InventoryObject)
-                    {
-                        Logger.DebugLog("Adding attachment (object) " + ib.Name, Client);
-                        attachments.Add(ib);
-                    }
-                    else
-                    {
-                        Logger.DebugLog("Ignoring inventory item " + ib.Name, Client);
-                    }
-                }
-            }
-            else
-            {
-                Logger.Log("Failed to download folder contents of + " + folder.ToString(),
-                    Helpers.LogLevel.Error, Client);
-                return false;
-            }
-
-            return true;
-        }
-
-        // this method will download the assets for all inventory items in iws
-        private void ReplaceOutfitWearables(List<InventoryWearable> iws)
-        {
-            lock (Wearables.Dictionary)
-            {
-                Dictionary<WearableType, WearableData> preserve = new Dictionary<WearableType,WearableData>();
-                
-                foreach (KeyValuePair<WearableType,WearableData> kvp in Wearables.Dictionary)
-                {
-                    if (kvp.Value.Item.AssetType == AssetType.Bodypart)
-                            preserve.Add(kvp.Key, kvp.Value);
-                }
-
-                Wearables.Dictionary = preserve;
-            
-                foreach (InventoryWearable iw in iws)
-                {
-                    WearableData wd = new WearableData();
-                    wd.Item = iw; 
-                    Wearables.Dictionary[wd.Item.WearableType] = wd;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Adds a list of attachments to avatar
-        /// </summary>
-        /// <param name="attachments">A List containing the attachments to add</param>
-        /// <param name="removeExistingFirst">If true, tells simulator to remove existing attachment
-        /// first</param>
-        public void AddAttachments(List<InventoryBase> attachments, bool removeExistingFirst)
-        {
-            // FIXME: Obey this
-            //const int OBJECTS_PER_PACKET = 4;
-
-            // Use RezMultipleAttachmentsFromInv  to clear out current attachments, and attach new ones
-            RezMultipleAttachmentsFromInvPacket attachmentsPacket = new RezMultipleAttachmentsFromInvPacket();
-            attachmentsPacket.AgentData.AgentID = Client.Self.AgentID;
-            attachmentsPacket.AgentData.SessionID = Client.Self.SessionID;
-
-            attachmentsPacket.HeaderData.CompoundMsgID = UUID.Random();
-            attachmentsPacket.HeaderData.FirstDetachAll = true;
-            attachmentsPacket.HeaderData.TotalObjects = (byte)attachments.Count;
-
-            attachmentsPacket.ObjectData = new RezMultipleAttachmentsFromInvPacket.ObjectDataBlock[attachments.Count];
-            for (int i = 0; i < attachments.Count; i++)
-            {
-                if (attachments[i] is InventoryAttachment)
-                {
-                    InventoryAttachment attachment = (InventoryAttachment)attachments[i];
-                    attachmentsPacket.ObjectData[i] = new RezMultipleAttachmentsFromInvPacket.ObjectDataBlock();
-                    attachmentsPacket.ObjectData[i].AttachmentPt = 0;
-                    attachmentsPacket.ObjectData[i].EveryoneMask = (uint)attachment.Permissions.EveryoneMask;
-                    attachmentsPacket.ObjectData[i].GroupMask = (uint)attachment.Permissions.GroupMask;
-                    attachmentsPacket.ObjectData[i].ItemFlags = (uint)attachment.Flags;
-                    attachmentsPacket.ObjectData[i].ItemID = attachment.UUID;
-                    attachmentsPacket.ObjectData[i].Name = Utils.StringToBytes(attachment.Name);
-                    attachmentsPacket.ObjectData[i].Description = Utils.StringToBytes(attachment.Description);
-                    attachmentsPacket.ObjectData[i].NextOwnerMask = (uint)attachment.Permissions.NextOwnerMask;
-                    attachmentsPacket.ObjectData[i].OwnerID = attachment.OwnerID;
-                }
-                else if (attachments[i] is InventoryObject)
-                {
-                    InventoryObject attachment = (InventoryObject)attachments[i];
-                    attachmentsPacket.ObjectData[i] = new RezMultipleAttachmentsFromInvPacket.ObjectDataBlock();
-                    attachmentsPacket.ObjectData[i].AttachmentPt = 0;
-                    attachmentsPacket.ObjectData[i].EveryoneMask = (uint)attachment.Permissions.EveryoneMask;
-                    attachmentsPacket.ObjectData[i].GroupMask = (uint)attachment.Permissions.GroupMask;
-                    attachmentsPacket.ObjectData[i].ItemFlags = (uint)attachment.Flags;
-                    attachmentsPacket.ObjectData[i].ItemID = attachment.UUID;
-                    attachmentsPacket.ObjectData[i].Name = Utils.StringToBytes(attachment.Name);
-                    attachmentsPacket.ObjectData[i].Description = Utils.StringToBytes(attachment.Description);
-                    attachmentsPacket.ObjectData[i].NextOwnerMask = (uint)attachment.Permissions.NextOwnerMask;
-                    attachmentsPacket.ObjectData[i].OwnerID = attachment.OwnerID;
-                }
-                else
-                {
-                    Logger.Log("Cannot attach inventory item of type " + attachments[i].GetType().ToString(),
-                        Helpers.LogLevel.Warning, Client);
-                }
-            }
-
-            Client.Network.SendPacket(attachmentsPacket);
-        }
-
-        /// <summary>
-        /// Attach an item to an avatar at a specific attach point
-        /// </summary>
-        /// <param name="item">A <seealso cref="OpenMetaverse.InventoryItem"/> to attach</param>
-        /// <param name="attachPoint">the <seealso cref="OpenMetaverse.AttachmentPoint"/> on the avatar 
-        /// to attach the item to</param>
-        public void Attach(InventoryItem item, AttachmentPoint attachPoint)
-        {
-            Attach(item.UUID, item.OwnerID, item.Name, item.Description, item.Permissions, item.Flags, 
-                attachPoint);
-        }
-
-        /// <summary>
-        /// Attach an item to an avatar specifying attachment details
-        /// </summary>
-        /// <param name="itemID">The <seealso cref="OpenMetaverse.UUID"/> of the item to attach</param>
-        /// <param name="ownerID">The <seealso cref="OpenMetaverse.UUID"/> attachments owner</param>
-        /// <param name="name">The name of the attachment</param>
-        /// <param name="description">The description of the attahment</param>
-        /// <param name="perms">The <seealso cref="OpenMetaverse.Permissions"/> to apply when attached</param>
-        /// <param name="itemFlags">The <seealso cref="OpenMetaverse.InventoryItemFlags"/> of the attachment</param>
-        /// <param name="attachPoint">the <seealso cref="OpenMetaverse.AttachmentPoint"/> on the avatar 
-        /// to attach the item to</param>
-        public void Attach(UUID itemID, UUID ownerID, string name, string description,
-            Permissions perms, uint itemFlags, AttachmentPoint attachPoint)
-        {
-            // TODO: At some point it might be beneficial to have AppearanceManager track what we
-            // are currently wearing for attachments to make enumeration and detachment easier
-
-            RezSingleAttachmentFromInvPacket attach = new RezSingleAttachmentFromInvPacket();
-
-            attach.AgentData.AgentID = Client.Self.AgentID;
-            attach.AgentData.SessionID = Client.Self.SessionID;
-
-            attach.ObjectData.AttachmentPt = (byte)attachPoint;
-            attach.ObjectData.Description = Utils.StringToBytes(description);
-            attach.ObjectData.EveryoneMask = (uint)perms.EveryoneMask;
-            attach.ObjectData.GroupMask = (uint)perms.GroupMask;
-            attach.ObjectData.ItemFlags = itemFlags;
-            attach.ObjectData.ItemID = itemID;
-            attach.ObjectData.Name = Utils.StringToBytes(name);
-            attach.ObjectData.NextOwnerMask = (uint)perms.NextOwnerMask;
-            attach.ObjectData.OwnerID = ownerID;
-
-            Client.Network.SendPacket(attach);
-        }
-
-        /// <summary>
-        /// Detach an item from avatar using an <seealso cref="OpenMetaverse.InventoryItem"/> object
-        /// </summary>
-        /// <param name="item">An <seealso cref="OpenMetaverse.InventoryItem"/> object</param>
-        public void Detach(InventoryItem item)
-        {
-            Detach(item.UUID); 
-        }
-
-        /// <summary>
-        /// Detach an Item from avatar by items <seealso cref="OpenMetaverse.UUID"/>
-        /// </summary>
-        /// <param name="itemID">The items ID to detach</param>
-        public void Detach(UUID itemID)
-        {
-            DetachAttachmentIntoInvPacket detach = new DetachAttachmentIntoInvPacket();
-            detach.ObjectData.AgentID = Client.Self.AgentID;
-            detach.ObjectData.ItemID = itemID;
-
-            Client.Network.SendPacket(detach);
-        }
-
-
-        private void UpdateAppearanceFromWearables(bool bake)
-        {
-            lock (AgentTextures)
-            {
-                for (int i = 0; i < AgentTextures.Length; i++)
-                    AgentTextures[i] = UUID.Zero;
-            }
-
-            // Register an asset download callback to get wearable data
-            AssetManager.AssetReceivedCallback assetCallback = new AssetManager.AssetReceivedCallback(Assets_OnAssetReceived);
-            AssetManager.ImageReceivedCallback imageCallback = new AssetManager.ImageReceivedCallback(Assets_OnImageReceived);
-            AssetManager.AssetUploadedCallback uploadCallback = new AssetManager.AssetUploadedCallback(Assets_OnAssetUploaded);
-            Assets.OnAssetReceived += assetCallback;
-            Assets.OnImageReceived += imageCallback;
-            Assets.OnAssetUploaded += uploadCallback;
-
-            // Download assets for what we are wearing and fill in AgentTextures
-            DownloadWearableAssets();
-            WearablesDownloadedEvent.WaitOne();
-
-            // Unregister the asset download callback
-            Assets.OnAssetReceived -= assetCallback;
-
-            // Check if anything needs to be rebaked
-            if (bake) RequestCachedBakes();
-
-            // Tell the sim what we are wearing
-            SendAgentIsNowWearing();
-
-            // Wait for cached layer check to finish
-            if (bake) CachedResponseEvent.WaitOne();
-
-            // Unregister the image download and asset upload callbacks
-            Assets.OnImageReceived -= imageCallback;
-            Assets.OnAssetUploaded -= uploadCallback;
-
-            Logger.DebugLog("CachedResponseEvent completed", Client);
-
-            #region Send Appearance
-
-            Primitive.TextureEntry te = null;
-
-            ObjectManager.NewAvatarCallback updateCallback =
-                delegate(Simulator simulator, Avatar avatar, ulong regionHandle, ushort timeDilation)
-                {
-                    if (avatar.LocalID == Client.Self.LocalID)
-                    {
-                        if (avatar.Textures.FaceTextures != null)
-                        {
-                            bool match = true;
-
-                            for (uint i = 0; i < AgentTextures.Length; i++)
-                            {
-                                Primitive.TextureEntryFace face = avatar.Textures.FaceTextures[i];
-
-                                if (face == null)
-                                {
-                                    // If the texture is UUID.Zero the face should be null
-                                    if (AgentTextures[i] != UUID.Zero)
-                                    {
-                                        match = false;
-                                        break;
-                                    }
-                                }
-                                else if (face.TextureID != AgentTextures[i])
-                                {
-                                    match = false;
-                                    break;
-                                }
-                            }
-
-                            if (!match)
-                                Logger.Log("TextureEntry mismatch after updating our appearance", Helpers.LogLevel.Warning, Client);
-
-                            te = avatar.Textures;
-                            UpdateEvent.Set();
-                        }
-                        else
-                        {
-                            Logger.Log("Received an update for our avatar with a null FaceTextures array",
-                                Helpers.LogLevel.Warning, Client);
-                        }
-                    }
-                };
-            Client.Objects.OnNewAvatar += updateCallback;
-
-            // Send all of the visual params and textures for our agent
-            SendAgentSetAppearance();
-
-            // Wait for the ObjectUpdate to come in for our avatar after changing appearance
-            if (UpdateEvent.WaitOne(1000 * 60, false))
-            {
-                if (OnAppearanceUpdated != null)
-                {
-                    try { OnAppearanceUpdated(te); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-            }
-            else
-            {
-                Logger.Log("Timed out waiting for our appearance to update on the simulator", Helpers.LogLevel.Warning, Client);
-            }
-
-            Client.Objects.OnNewAvatar -= updateCallback;
-
-            #endregion Send Appearance
-        }
-
-        /// <summary>
-        /// Build hashes out of the texture assetIDs for each baking layer to
-        /// ask the simulator whether it has cached copies of each baked texture
-        /// </summary>
-        public void RequestCachedBakes()
-        {
-            Logger.DebugLog("RequestCachedBakes()", Client);
-            
-            List<KeyValuePair<int, UUID>> hashes = new List<KeyValuePair<int,UUID>>();
-
-            AgentCachedTexturePacket cache = new AgentCachedTexturePacket();
-            cache.AgentData.AgentID = Client.Self.AgentID;
-            cache.AgentData.SessionID = Client.Self.SessionID;
-            cache.AgentData.SerialNum = CacheCheckSerialNum;
-
-            // Build hashes for each of the bake layers from the individual components
-            for (int bakedIndex = 0; bakedIndex < BAKED_TEXTURE_COUNT; bakedIndex++)
-            {
-                // Don't do a cache request for a skirt bake if we're not wearing a skirt
-                if (bakedIndex == (int)BakeType.Skirt && 
-                    (!Wearables.ContainsKey(WearableType.Skirt) || Wearables.Dictionary[WearableType.Skirt].Asset.AssetID == UUID.Zero))
-                    continue;
-
-                UUID hash = new UUID();
-
-                for (int wearableIndex = 0; wearableIndex < WEARABLES_PER_LAYER; wearableIndex++)
-                {
-                    WearableType type = WEARABLE_BAKE_MAP[bakedIndex][wearableIndex];
-                    UUID assetID = GetWearableAsset(type);
-
-                    // Build a hash of all the texture asset IDs in this baking layer
-                    if (assetID != UUID.Zero) hash ^= assetID;
-                }
-
-                if (hash != UUID.Zero)
-                {
-                    // Hash with our secret value for this baked layer
-                    hash ^= BAKED_TEXTURE_HASH[bakedIndex];
-
-                    // Add this to the list of hashes to send out
-                    hashes.Add(new KeyValuePair<int, UUID>(bakedIndex, hash));
-                }
-            }
-
-            // Only send the packet out if there's something to check
-            if (hashes.Count > 0)
-            {
-                cache.WearableData = new AgentCachedTexturePacket.WearableDataBlock[hashes.Count];
-
-                for (int i = 0; i < hashes.Count; i++)
-                {
-                    cache.WearableData[i] = new AgentCachedTexturePacket.WearableDataBlock();
-                    cache.WearableData[i].TextureIndex = (byte)hashes[i].Key;
-                    cache.WearableData[i].ID = hashes[i].Value;
-
-                    Logger.DebugLog("Checking cache for index " + cache.WearableData[i].TextureIndex +
-                        ", ID: " + cache.WearableData[i].ID, Client);
-                }
-
-                // Increment our serial number for this packet
-                CacheCheckSerialNum++;
-
-                // Send it out
-                Client.Network.SendPacket(cache);
-            }
-        }
-
-        /// <summary>
-        /// Ask the server what textures our avatar is currently wearing
-        /// </summary>
-        public void SendAgentWearablesRequest()
-        {
-            AgentWearablesRequestPacket request = new AgentWearablesRequestPacket();
-            request.AgentData.AgentID = Client.Self.AgentID;
-            request.AgentData.SessionID = Client.Self.SessionID;
-
-            Client.Network.SendPacket(request);
-        }
-
-        private void AgentWearablesUpdateHandler(Packet packet, Simulator simulator)
-        {
-            // Lock to prevent a race condition with multiple AgentWearables packets
-            lock (WearablesRequestEvent)
-            {
-                AgentWearablesUpdatePacket update = (AgentWearablesUpdatePacket)packet;
-
-                // Reset the Wearables collection
-                lock (Wearables.Dictionary) Wearables.Dictionary.Clear();
-
-                for (int i = 0; i < update.WearableData.Length; i++)
-                {
-                    if (update.WearableData[i].AssetID != UUID.Zero)
-                    {
-                        WearableType type = (WearableType)update.WearableData[i].WearableType;
-                        WearableData data = new WearableData();
-                        data.Item = new InventoryWearable(update.WearableData[i].ItemID);
-                        data.Item.WearableType = type;
-                        data.Item.AssetType = WearableTypeToAssetType(type);
-                        data.Item.AssetUUID = update.WearableData[i].AssetID;
-
-                        // Add this wearable to our collection
-                        lock (Wearables.Dictionary) Wearables.Dictionary[type] = data;
-                    }
-                }
-            }
-
-            WearablesRequestEvent.Set();
-        }
-
-        private void SendAgentSetAppearance()
-        {
-            AgentSetAppearancePacket set = new AgentSetAppearancePacket();
-            set.AgentData.AgentID = Client.Self.AgentID;
-            set.AgentData.SessionID = Client.Self.SessionID;
-            set.AgentData.SerialNum = SetAppearanceSerialNum++;
-            set.VisualParam = new AgentSetAppearancePacket.VisualParamBlock[218];
-
-            float AgentSizeVPHeight = 0.0f;
-            float AgentSizeVPHeelHeight = 0.0f;
-            float AgentSizeVPPlatformHeight = 0.0f;
-            float AgentSizeVPHeadSize = 0.5f;
-            float AgentSizeVPLegLength = 0.0f;
-            float AgentSizeVPNeckLength = 0.0f;
-            float AgentSizeVPHipLength = 0.0f;
-
-            lock (Wearables.Dictionary)
-            {
-                // Only for debugging output
-                int count = 0, vpIndex = 0;
-
-                // Build the visual param array
-                foreach (KeyValuePair<int, VisualParam> kvp in VisualParams.Params)
-                {
-                    VisualParam vp = kvp.Value;
-
-                    // Only Group-0 parameters are sent in AgentSetAppearance packets
-                    if (vp.Group == 0)
-                    {
-                        set.VisualParam[vpIndex] = new AgentSetAppearancePacket.VisualParamBlock();
-
-                        // Try and find this value in our collection of downloaded wearables
-                        foreach (WearableData data in Wearables.Dictionary.Values)
-                        {
-                            if (data.Asset != null && data.Asset.Params.ContainsKey(vp.ParamID))
-                            {
-                                set.VisualParam[vpIndex].ParamValue = Utils.FloatToByte(data.Asset.Params[vp.ParamID], vp.MinValue, vp.MaxValue);
-                                count++;
-
-                                switch (vp.ParamID)
-                                {
-                                    case 33:
-                                        AgentSizeVPHeight = data.Asset.Params[vp.ParamID];
-                                        break;
-                                    case 198:
-                                        AgentSizeVPHeelHeight = data.Asset.Params[vp.ParamID];
-                                        break;
-                                    case 503:
-                                        AgentSizeVPPlatformHeight = data.Asset.Params[vp.ParamID];
-                                        break;
-                                    case 682:
-                                        AgentSizeVPHeadSize = data.Asset.Params[vp.ParamID];
-                                        break;
-                                    case 692:
-                                        AgentSizeVPLegLength = data.Asset.Params[vp.ParamID];
-                                        break;
-                                    case 756:
-                                        AgentSizeVPNeckLength = data.Asset.Params[vp.ParamID];
-                                        break;
-                                    case 842:
-                                        AgentSizeVPHipLength = data.Asset.Params[vp.ParamID];
-                                        break;
-                                }
-                                break;
-                            }
-                        }
-
-                        ++vpIndex;
-                    }
-                }
-
-                // Build the texture entry for our agent
-                Primitive.TextureEntry te = new Primitive.TextureEntry(DEFAULT_AVATAR_TEXTURE);
-
-                // Put our AgentTextures array in to TextureEntry
-                lock (AgentTextures)
-                {
-                    for (uint i = 0; i < AgentTextures.Length; i++)
-                    {
-                        if (AgentTextures[i] != UUID.Zero)
-                        {
-                            Primitive.TextureEntryFace face = te.CreateFace(i);
-                            face.TextureID = AgentTextures[i];
-                        }
-                    }
-                }
-
-                foreach (WearableData data in Wearables.Dictionary.Values)
-                {
-                    if (data.Asset != null)
-                    {
-                        foreach (KeyValuePair<TextureIndex, UUID> texture in data.Asset.Textures)
-                        {
-                            Primitive.TextureEntryFace face = te.CreateFace((uint)texture.Key);
-                            face.TextureID = texture.Value;
-
-                            Logger.DebugLog("Setting agent texture " + ((TextureIndex)texture.Key).ToString() + " to " +
-                                texture.Value.ToString(), Client);
-                        }
-                    }
-                }
-
-                // Set the packet TextureEntry
-                set.ObjectData.TextureEntry = te.ToBytes();
-            }
-
-            // FIXME: Our hackish algorithm is making squished avatars. See
-            // http://www.OpenMetaverse.org/wiki/Agent_Size for discussion of the correct algorithm
-            //float height = Utils.ByteToFloat(set.VisualParam[33].ParamValue, VisualParams.Params[33].MinValue,
-            //    VisualParams.Params[33].MaxValue);
-
-            // Takes into account the Shoe Heel/Platform offsets but not the Head Size Offset.  But seems to work.
-            double AgentSizeBase = 1.706;
-
-            // The calculation for the Head Size scalar may be incorrect.  But seems to work.
-            double AgentHeight = AgentSizeBase + (AgentSizeVPLegLength * .1918) + (AgentSizeVPHipLength * .0375) +
-                (AgentSizeVPHeight * .12022) + (AgentSizeVPHeadSize * .01117) + (AgentSizeVPNeckLength * .038) +
-                (AgentSizeVPHeelHeight * .08) + (AgentSizeVPPlatformHeight * .07);
-
-            set.AgentData.Size = new Vector3(0.45f, 0.6f, (float)AgentHeight);
-
-            // TODO: Account for not having all the textures baked yet
-            set.WearableData = new AgentSetAppearancePacket.WearableDataBlock[BAKED_TEXTURE_COUNT];
-
-            // Build hashes for each of the bake layers from the individual components
-            for (int bakedIndex = 0; bakedIndex < BAKED_TEXTURE_COUNT; bakedIndex++)
-            {
-                UUID hash = new UUID();
-
-                for (int wearableIndex = 0; wearableIndex < WEARABLES_PER_LAYER; wearableIndex++)
-                {
-                    WearableType type = WEARABLE_BAKE_MAP[bakedIndex][wearableIndex];
-                    UUID assetID = GetWearableAsset(type);
-
-                    // Build a hash of all the texture asset IDs in this baking layer
-                    if (assetID != UUID.Zero) hash ^= assetID;
-                }
-
-                if (hash != UUID.Zero)
-                {
-                    // Hash with our secret value for this baked layer
-                    hash ^= BAKED_TEXTURE_HASH[bakedIndex];
-                }
-
-                // Tell the server what cached texture assetID to use for each bake layer
-                set.WearableData[bakedIndex] = new AgentSetAppearancePacket.WearableDataBlock();
-                set.WearableData[bakedIndex].TextureIndex = (byte)bakedIndex;
-                set.WearableData[bakedIndex].CacheID = hash;
-            }
-
-            // Finally, send the packet
-            Client.Network.SendPacket(set);
-        }
-
-
-        private void SendAgentIsNowWearing()
-        {
-            Logger.DebugLog("SendAgentIsNowWearing()", Client);
-
-            AgentIsNowWearingPacket wearing = new AgentIsNowWearingPacket();
-            wearing.AgentData.AgentID = Client.Self.AgentID;
-            wearing.AgentData.SessionID = Client.Self.SessionID;
-            wearing.WearableData = new AgentIsNowWearingPacket.WearableDataBlock[WEARABLE_COUNT];
-
-            for (int i = 0; i < WEARABLE_COUNT; i++)
-            {
-                WearableType type = (WearableType)i;
-                wearing.WearableData[i] = new AgentIsNowWearingPacket.WearableDataBlock();
-                wearing.WearableData[i].WearableType = (byte)i;
-
-                if (Wearables.ContainsKey(type))
-                    wearing.WearableData[i].ItemID = Wearables.Dictionary[type].Item.UUID;
-                else
-                    wearing.WearableData[i].ItemID = UUID.Zero;
-            }
-
-            Client.Network.SendPacket(wearing);
-        }
-
-        private TextureIndex BakeTypeToAgentTextureIndex(BakeType index)
-        {
-            switch (index)
-            {
-                case BakeType.Head:
-                    return TextureIndex.HeadBaked;
-                case BakeType.UpperBody:
-                    return TextureIndex.UpperBaked;
-                case BakeType.LowerBody:
-                    return TextureIndex.LowerBaked;
-                case BakeType.Eyes:
-                    return TextureIndex.EyesBaked;
-                case BakeType.Skirt:
-                    return TextureIndex.SkirtBaked;
-                default:
-                    return TextureIndex.Unknown;
-            }
-        }
-
-        private void DownloadWearableAssets()
-        {
-            foreach (KeyValuePair<WearableType, WearableData> kvp in Wearables.Dictionary)
-            {
-                Logger.DebugLog("Requesting asset for wearable item " + kvp.Value.Item.WearableType + " (" + kvp.Value.Item.AssetUUID + ")", Client);
-                AssetDownloads.Enqueue(new PendingAssetDownload(kvp.Value.Item.AssetUUID, kvp.Value.Item.AssetType));
-            }
-
-            if (AssetDownloads.Count > 0)
-            {
-                PendingAssetDownload pad = AssetDownloads.Dequeue();
-                Assets.RequestAsset(pad.Id, pad.Type, true);
-            }
-        }
-
-        private void UploadBake(Baker bake)
-        {
-            if(bake.BakedTexture.AssetID==UUID.Zero)
-            {
-                Logger.Log("UploadBake(): Warning possible Linden Default textures in use, skipping this baked upload",Helpers.LogLevel.Warning, Client);
-                return;
-            }
-
-            lock (PendingUploads)
-            {
-                if(PendingUploads.ContainsKey(bake.BakedTexture.AssetID))
-                {
-                    Logger.Log("UploadBake(): Skipping Asset id "+bake.BakedTexture.AssetID.ToString()+" Already in progress",Helpers.LogLevel.Info, Client);
-                    return;
-                }
-
-             // Add it to a pending uploads list
-             PendingUploads.Add(bake.BakedTexture.AssetID, BakeTypeToAgentTextureIndex(bake.BakeType));
-             }
-
-            // Upload the completed layer data
-            Assets.RequestUpload(bake.BakedTexture, true);
-
-            Logger.DebugLog(String.Format("Bake {0} completed. Uploading asset {1}", bake.BakeType,
-                bake.BakedTexture.AssetID.ToString()), Client);
-
-        }
-
-        private int AddImageDownload(TextureIndex index)
-        {
-            UUID image = AgentTextures[(int)index];
-
-            if (image != UUID.Zero)
-            {
-                if (!ImageDownloads.ContainsKey(image))
-                {
-                    Logger.DebugLog("Downloading layer " + index.ToString(), Client);
-                    ImageDownloads.Add(image, index);
-                }
-
-                return 1;
-            }
-
-            return 0;
-        }
-
-        #region Callbacks
-
-        private void AgentCachedTextureResponseHandler(Packet packet, Simulator simulator)
-        {
-            Logger.DebugLog("AgentCachedTextureResponseHandler()", Client);
-            
-            AgentCachedTextureResponsePacket response = (AgentCachedTextureResponsePacket)packet;
-            Dictionary<int, float> paramValues = new Dictionary<int, float>(VisualParams.Params.Count);
-
-            // Build a dictionary of appearance parameter indices and values from the wearables
-            foreach (KeyValuePair<int,VisualParam> kvp in VisualParams.Params)
-            {
-                // Only Group-0 parameters are sent in AgentSetAppearance packets
-                if (kvp.Value.Group == 0)
-                {
-                    bool found = false;
-                    VisualParam vp = kvp.Value;
-
-                    // Try and find this value in our collection of downloaded wearables
-                    foreach (WearableData data in Wearables.Dictionary.Values)
-                    {
-                        if (data.Asset.Params.ContainsKey(vp.ParamID))
-                        {
-                            paramValues.Add(vp.ParamID, data.Asset.Params[vp.ParamID]);
-                            found = true;
-                            break;
-                        }
-                    }
-
-                    // Use a default value if we don't have one set for it
-                    if (!found) paramValues.Add(vp.ParamID, vp.DefaultValue);
-                }
-            }
-
-            lock (AgentTextures)
-            {
-                foreach (AgentCachedTextureResponsePacket.WearableDataBlock block in response.WearableData)
-                {
-                    // For each missing element we need to bake our own texture
-                    Logger.DebugLog("Cache response, index: " + block.TextureIndex + ", ID: " +
-                        block.TextureID.ToString(), Client);
-
-                    // FIXME: Use this. Right now we treat baked images on other sims as if they were missing
-                    string host = Utils.BytesToString(block.HostName);
-                    if (host.Length > 0) Logger.DebugLog("Cached bake exists on foreign host " + host, Client);
-
-                    BakeType bakeType = (BakeType)block.TextureIndex;
-                    
-                    // Convert the baked index to an AgentTexture index
-                    if (block.TextureID != UUID.Zero && host.Length == 0)
-                    {
-                        TextureIndex index = BakeTypeToAgentTextureIndex(bakeType);
-                        AgentTextures[(int)index] = block.TextureID;
-                    }
-                    else
-                    {
-                        int imageCount = 0;
-
-                        // Download all of the images in this layer
-                        switch (bakeType)
-                        {
-                            case BakeType.Head:
-                                lock (ImageDownloads)
-                                {
-                                    imageCount += AddImageDownload(TextureIndex.HeadBodypaint);
-                                    //imageCount += AddImageDownload(TextureIndex.Hair);
-                                }
-                                break;
-                            case BakeType.UpperBody:
-                                lock (ImageDownloads)
-                                {
-                                    imageCount += AddImageDownload(TextureIndex.UpperBodypaint);
-                                    imageCount += AddImageDownload(TextureIndex.UpperGloves);
-                                    imageCount += AddImageDownload(TextureIndex.UpperUndershirt);
-                                    imageCount += AddImageDownload(TextureIndex.UpperShirt);
-                                    imageCount += AddImageDownload(TextureIndex.UpperJacket);
-                                }
-                                break;
-                            case BakeType.LowerBody:
-                                lock (ImageDownloads)
-                                {
-                                    imageCount += AddImageDownload(TextureIndex.LowerBodypaint);
-                                    imageCount += AddImageDownload(TextureIndex.LowerUnderpants);
-                                    imageCount += AddImageDownload(TextureIndex.LowerSocks);
-                                    imageCount += AddImageDownload(TextureIndex.LowerShoes);
-                                    imageCount += AddImageDownload(TextureIndex.LowerPants);
-                                    imageCount += AddImageDownload(TextureIndex.LowerJacket);
-                                }
-                                break;
-                            case BakeType.Eyes:
-                                lock (ImageDownloads)
-                                {
-                                    imageCount += AddImageDownload(TextureIndex.EyesIris);
-                                }
-                                break;
-                            case BakeType.Skirt:
-                                if (Wearables.ContainsKey(WearableType.Skirt))
-                                {
-                                    lock (ImageDownloads)
-                                    {
-                                        imageCount += AddImageDownload(TextureIndex.Skirt);
-                                    }
-                                }
-                                break;
-                            default:
-                                Logger.Log("Unknown BakeType " + block.TextureIndex, Helpers.LogLevel.Warning, Client);
-                                break;
-                        }
-
-                        if (!PendingBakes.ContainsKey(bakeType))
-                        {
-                            Logger.DebugLog("Initializing " + bakeType.ToString() + " bake with " + imageCount + " textures", Client);
-
-                            if (imageCount == 0)
-                            {
-                                // if there are no textures to download, we can bake right away and start the upload
-                                Baker bake = new Baker(Client, bakeType, 0, paramValues);
-                                UploadBake(bake);
-                            }
-                            else
-                            {
-                                lock (PendingBakes)
-                                    PendingBakes.Add(bakeType, new Baker(Client, bakeType, imageCount, paramValues));
-                            }
-                        }
-                        else if (!PendingBakes.ContainsKey(bakeType))
-                        {
-                            Logger.Log("No cached bake for " + bakeType.ToString() + " and no textures for that " +
-                                "layer, this is an unhandled case", Helpers.LogLevel.Error, Client);
-                        }
-                    }
-                }
-            }
-
-            if (ImageDownloads.Count == 0)
-            {
-                // No pending downloads for baking, we're done
-                CachedResponseEvent.Set();
-            }
-            else
-            {
-                lock (ImageDownloads)
-                {
-                    List<UUID> imgKeys = new List<UUID>(ImageDownloads.Keys);
-                    foreach (UUID image in imgKeys)
-                    {
-                        // Download all the images we need for baking
-                        Assets.RequestImage(image, ImageType.Normal, 1013000.0f, 0, 0);
-                    }
-                }
-            }
-        }
-
-        private void Assets_OnAssetReceived(AssetDownload download, Asset asset)
-        {
-            lock (Wearables.Dictionary)
-            {
-                // Check if this is a wearable we were waiting on
-                foreach (KeyValuePair<WearableType,WearableData> kvp in Wearables.Dictionary)
-                {
-                    if (kvp.Value.Item.AssetUUID == download.AssetID)
-                    {
-                        // Make sure the download succeeded
-                        if (download.Success)
-                        {
-                            kvp.Value.Asset = (AssetWearable)asset;
-
-                            Logger.DebugLog("Downloaded wearable asset " + kvp.Value.Asset.Name, Client);
-
-                            if (!kvp.Value.Asset.Decode())
-                            {
-                                Logger.Log("Failed to decode asset:" + Environment.NewLine +
-                                    Utils.BytesToString(asset.AssetData), Helpers.LogLevel.Error, Client);
-                            }
-
-                            lock (AgentTextures)
-                            {
-                                foreach (KeyValuePair<AppearanceManager.TextureIndex, UUID> texture in kvp.Value.Asset.Textures)
-                                {
-                                    if (texture.Value != DEFAULT_AVATAR_TEXTURE) // this texture is not meant to be displayed
-                                    {
-                                        Logger.DebugLog("Setting " + texture.Key + " to " + texture.Value, Client);
-                                        AgentTextures[(int)texture.Key] = texture.Value;
-                                    }
-                                }
-                            }
-                        }
-                        else
-                        {
-                            Logger.Log("Wearable " + kvp.Key + "(" + download.AssetID.ToString() + ") failed to download, " +
-                                download.Status.ToString(), Helpers.LogLevel.Warning, Client);
-                        }
-
-                        break;
-                    }
-                }
-            }
-
-            if (AssetDownloads.Count > 0)
-            {
-                // Dowload the next wearable in line
-                PendingAssetDownload pad = AssetDownloads.Dequeue();
-                Assets.RequestAsset(pad.Id, pad.Type, true);
-            }
-            else
-            {
-                // Everything is downloaded
-                if (OnAgentWearables != null)
-                {
-                    try { OnAgentWearables(); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-
-                WearablesDownloadedEvent.Set();
-            }
-        }
-
-        private void Assets_OnImageReceived(ImageDownload image, AssetTexture assetTexture)
-        {
-            lock (ImageDownloads)
-            {
-                if (ImageDownloads.ContainsKey(image.ID))
-                {
-                    ImageDownloads.Remove(image.ID);
-
-                    // NOTE: This image may occupy more than one TextureIndex! We must finish this loop
-                    for (int at = 0; at < AgentTextures.Length; at++)
-                    {
-                        if (AgentTextures[at] == image.ID)
-                        {
-                            TextureIndex index = (TextureIndex)at;
-                            BakeType type = Baker.BakeTypeFor(index);
-
-                            //BinaryWriter writer = new BinaryWriter(File.Create("wearable_" + index.ToString() + "_" + image.ID.ToString() + ".jp2"));
-                            //writer.Write(image.AssetData);
-                            //writer.Close();
-
-                            bool baked = false;
-
-                            if (PendingBakes.ContainsKey(type))
-                            {
-                                if (image.Success)
-                                {
-                                    Logger.DebugLog("Finished downloading texture for " + index.ToString(), Client);
-                                    OpenJPEG.DecodeToImage(image.AssetData, out assetTexture.Image);
-                                    baked = PendingBakes[type].AddTexture(index, assetTexture, false);
-                                }
-                                else
-                                {
-                                    Logger.Log("Texture for " + index.ToString() + " failed to download, " +
-                                        "bake will be incomplete", Helpers.LogLevel.Warning, Client);
-                                    baked = PendingBakes[type].MissingTexture(index);
-                                }
-                            }
-
-                            if (baked)
-                            {
-                                UploadBake(PendingBakes[type]);
-                                PendingBakes.Remove(type);
-                            }
-
-                            if (ImageDownloads.Count == 0 && PendingUploads.Count == 0)
-                            {
-                                // This is a failsafe catch, as the upload completed callback should normally 
-                                // be triggering the event
-                                Logger.DebugLog("No pending downloads or uploads detected in OnImageReceived", Client);
-                                CachedResponseEvent.Set();
-                            }
-                            else
-                            {
-                                Logger.DebugLog("Pending uploads: " + PendingUploads.Count + ", pending downloads: " +
-                                    ImageDownloads.Count, Client);
-                            }
-
-                        }
-                    }
-                }
-                else
-                {
-                    Logger.Log("Received an image download callback for an image we did not request " + image.ID.ToString(),
-                        Helpers.LogLevel.Warning, Client);
-                }
-            }
-        }
-
-        private void Assets_OnAssetUploaded(AssetUpload upload)
-        {
-            lock (PendingUploads)
-            {
-                if (PendingUploads.ContainsKey(upload.AssetID))
-                {
-                    if (upload.Success)
-                    {
-                        // Setup the TextureEntry with the new baked upload
-                        TextureIndex index = PendingUploads[upload.AssetID];
-                        AgentTextures[(int)index] = upload.AssetID;
-
-                        Logger.DebugLog("Upload complete, AgentTextures " + index.ToString() + " set to " + 
-                            upload.AssetID.ToString(), Client);
-                    }
-                    else
-                    {
-                        Logger.Log("Asset upload " + upload.AssetID.ToString() + " failed", 
-                            Helpers.LogLevel.Warning, Client);
-                    }
-
-                    PendingUploads.Remove(upload.AssetID);
-
-                    Logger.DebugLog("Pending uploads: " + PendingUploads.Count + ", pending downloads: " +
-                        ImageDownloads.Count, Client);
-
-                    if (PendingUploads.Count == 0 && ImageDownloads.Count == 0)
-                    {
-                        Logger.DebugLog("All pending image downloads and uploads complete", Client);
-
-                        CachedResponseEvent.Set();
-                    }
-                }
-                else
-                {
-                    // TEMP
-                    Logger.DebugLog("Upload " + upload.AssetID.ToString() + " was not found in PendingUploads", Client);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Terminate any wait handles when the network layer disconnects
-        /// </summary>
-        private void Network_OnDisconnected(NetworkManager.DisconnectType reason, string message)
-        {
-            WearablesRequestEvent.Set();
-            WearablesDownloadedEvent.Set();
-            CachedResponseEvent.Set();
-            UpdateEvent.Set();
-        }
-
-        #endregion Callbacks
-    }
-}
+/*
+ * Copyright (c) 2006-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Text;
+using System.Collections.Generic;
+using System.Threading;
+using System.IO;
+using OpenMetaverse;
+using OpenMetaverse.Packets;
+using OpenMetaverse.Imaging;
+
+namespace OpenMetaverse
+{
+    public class InvalidOutfitException : Exception
+    {
+        public InvalidOutfitException(string message) : base(message) { }
+    }
+    
+    /// <summary>
+    /// Manager class to for agents appearance, both body parts and clothing
+    /// </summary>
+    public class AppearanceManager
+    {
+        /// <summary>
+        /// 
+        /// </summary>
+        public enum TextureIndex
+        {
+            Unknown = -1,
+            HeadBodypaint = 0,
+            UpperShirt,
+            LowerPants,
+            EyesIris,
+            Hair,
+            UpperBodypaint,
+            LowerBodypaint,
+            LowerShoes,
+            HeadBaked,
+            UpperBaked,
+            LowerBaked,
+            EyesBaked,
+            LowerSocks,
+            UpperJacket,
+            LowerJacket,
+            UpperGloves,
+            UpperUndershirt,
+            LowerUnderpants,
+            Skirt,
+            SkirtBaked
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        public enum BakeType
+        {
+            Unknown = -1,
+            Head = 0,
+            UpperBody = 1,
+            LowerBody = 2,
+            Eyes = 3,
+            Skirt = 4
+        }
+
+        public class WearableData
+        {
+            public InventoryWearable Item;
+            public AssetWearable Asset;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        public delegate void AgentWearablesCallback();
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="te"></param>
+        public delegate void AppearanceUpdatedCallback(Primitive.TextureEntry te);
+
+        /// <summary></summary>
+        public event AgentWearablesCallback OnAgentWearables;
+        /// <summary></summary>
+        public event AppearanceUpdatedCallback OnAppearanceUpdated;
+
+        /// <summary>Total number of wearables for each avatar</summary>
+        public const int WEARABLE_COUNT = 13;
+        /// <summary>Total number of baked textures on each avatar</summary>
+        public const int BAKED_TEXTURE_COUNT = 5;
+        /// <summary>Total number of wearables per bake layer</summary>
+        public const int WEARABLES_PER_LAYER = 7;
+        /// <summary>Total number of textures on an avatar, baked or not</summary>
+        public const int AVATAR_TEXTURE_COUNT = 20;
+        /// <summary>Map of what wearables are included in each bake</summary>
+        public static readonly WearableType[][] WEARABLE_BAKE_MAP = new WearableType[][]
+        {
+            new WearableType[] { WearableType.Shape, WearableType.Skin,    WearableType.Hair,    WearableType.Invalid, WearableType.Invalid, WearableType.Invalid,    WearableType.Invalid    },
+            new WearableType[] { WearableType.Shape, WearableType.Skin,    WearableType.Shirt,   WearableType.Jacket,  WearableType.Gloves,  WearableType.Undershirt, WearableType.Invalid    },
+            new WearableType[] { WearableType.Shape, WearableType.Skin,    WearableType.Pants,   WearableType.Shoes,   WearableType.Socks,   WearableType.Jacket,     WearableType.Underpants },
+            new WearableType[] { WearableType.Eyes,  WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid,    WearableType.Invalid    },
+            new WearableType[] { WearableType.Skirt, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid, WearableType.Invalid } 
+        };
+        /// <summary>Secret values to finalize the cache check hashes for each
+        /// bake</summary>
+        public static readonly UUID[] BAKED_TEXTURE_HASH = new UUID[]
+        {
+            new UUID("18ded8d6-bcfc-e415-8539-944c0f5ea7a6"),
+	        new UUID("338c29e3-3024-4dbb-998d-7c04cf4fa88f"),
+	        new UUID("91b4a2c7-1b1a-ba16-9a16-1f8f8dcc1c3f"),
+	        new UUID("b2cf28af-b840-1071-3c6a-78085d8128b5"),
+	        new UUID("ea800387-ea1a-14e0-56cb-24f2022f969a")
+        };
+        /// <summary>Default avatar texture, used to detect when a custom
+        /// texture is not set for a face</summary>
+        public static readonly UUID DEFAULT_AVATAR_TEXTURE = new UUID("c228d1cf-4b5d-4ba8-84f4-899a0796aa97");
+
+
+        private GridClient Client;
+        private AssetManager Assets;
+
+        /// <summary>
+        /// An <seealso cref="T:InternalDictionary"/> which keeps track of wearables data
+        /// </summary>
+        public InternalDictionary<WearableType, WearableData> Wearables = new InternalDictionary<WearableType, WearableData>();
+        // As wearable assets are downloaded and decoded, the textures are added to this array
+        private UUID[] AgentTextures = new UUID[AVATAR_TEXTURE_COUNT];
+
+        protected struct PendingAssetDownload
+        {
+            public UUID Id;
+            public AssetType Type;
+
+            public PendingAssetDownload(UUID id, AssetType type)
+            {
+                Id = id;
+                Type = type;
+            }
+        }
+        
+        // Wearable assets are downloaded one at a time, a new request is pulled off the queue
+        // and started when the previous one completes
+        private Queue<PendingAssetDownload> AssetDownloads = new Queue<PendingAssetDownload>();
+        // A list of all the images we are currently downloading, prior to baking
+        private Dictionary<UUID, TextureIndex> ImageDownloads = new Dictionary<UUID, TextureIndex>();
+        // A list of all the bakes we need to complete
+        private Dictionary<BakeType, Baker> PendingBakes = new Dictionary<BakeType, Baker>(BAKED_TEXTURE_COUNT);
+        // A list of all the uploads that are in progress
+        private Dictionary<UUID, TextureIndex> PendingUploads = new Dictionary<UUID, TextureIndex>(BAKED_TEXTURE_COUNT);
+        // Whether the handler for our current wearable list should automatically start downloading the assets
+        //private bool DownloadWearables = false;
+        private static int CacheCheckSerialNum = 1; //FIXME
+        private static uint SetAppearanceSerialNum = 1; //FIXME
+        private WearParams _wearOutfitParams;
+        private bool _bake;
+        private AutoResetEvent WearablesRequestEvent = new AutoResetEvent(false);
+        private AutoResetEvent WearablesDownloadedEvent = new AutoResetEvent(false);
+        private AutoResetEvent CachedResponseEvent = new AutoResetEvent(false);
+        private AutoResetEvent UpdateEvent = new AutoResetEvent(false);
+        // FIXME: Create a class-level appearance thread so multiple threads can't be launched
+
+        /// <summary>
+        /// Default constructor
+        /// </summary>
+        /// <param name="client">This agents <seealso cref="OpenMetaverse.GridClient"/> Object</param>
+        /// <param name="assets">Reference to an AssetManager object</param>
+        public AppearanceManager(GridClient client, AssetManager assets)
+        {
+            Client = client;
+            Assets = assets;
+
+            // Initialize AgentTextures to zero UUIDs
+            for (int i = 0; i < AgentTextures.Length; i++)
+                AgentTextures[i] = UUID.Zero;
+
+            Client.Network.RegisterCallback(PacketType.AgentWearablesUpdate, new NetworkManager.PacketCallback(AgentWearablesUpdateHandler));
+            Client.Network.RegisterCallback(PacketType.AgentCachedTextureResponse, new NetworkManager.PacketCallback(AgentCachedTextureResponseHandler));
+            Client.Network.OnDisconnected += new NetworkManager.DisconnectedCallback(Network_OnDisconnected);
+        }
+
+        private static AssetType WearableTypeToAssetType(WearableType type)
+        {
+            switch (type)
+            {
+                case WearableType.Shape:
+                case WearableType.Skin:
+                case WearableType.Hair:
+                case WearableType.Eyes:
+                    return AssetType.Bodypart;
+                case WearableType.Shirt:
+                case WearableType.Pants:
+                case WearableType.Shoes:
+                case WearableType.Socks:
+                case WearableType.Jacket:
+                case WearableType.Gloves:
+                case WearableType.Undershirt:
+                case WearableType.Underpants:
+                case WearableType.Skirt:
+                    return AssetType.Clothing;
+                default:
+                    throw new Exception("Unhandled wearable type " + type);
+            }
+        }
+
+        /// <summary>
+        /// Returns the assetID for a given WearableType 
+        /// </summary>
+        /// <param name="type">the <seealso cref="OpenMetaverse.WearableType"/> of the asset</param>
+        /// <returns>The <seealso cref="OpenMetaverse.UUID"/> of the WearableType</returns>
+        public UUID GetWearableAsset(WearableType type)
+        {
+            WearableData wearable;
+
+            if (Wearables.TryGetValue(type, out wearable))
+                return wearable.Item.AssetUUID;
+            else
+                return UUID.Zero;
+        }
+
+        /// <summary>
+        /// Ask the server what we are wearing and set appearance based on that
+        /// </summary>
+        public void SetPreviousAppearance()
+        {
+            SetPreviousAppearance(true);
+        }
+
+        public void SetPreviousAppearance(bool bake)
+        {
+            _bake = bake;
+            Thread appearanceThread = new Thread(new ThreadStart(StartSetPreviousAppearance));
+            appearanceThread.Start();
+        }
+
+        private void StartSetPreviousAppearance()
+        {
+            SendAgentWearablesRequest();
+            WearablesRequestEvent.WaitOne();
+            UpdateAppearanceFromWearables(_bake);
+        }
+
+        private class WearParams
+        {
+            public object Param;
+            public bool Bake;
+
+            public WearParams(object param, bool bake)
+            {
+                Param = param;
+                Bake = bake;
+            }
+        }
+
+        /// <summary>
+        /// Replace the current outfit with a list of wearables and set appearance
+        /// </summary>
+        /// <param name="ibs">List of wearables that define the new outfit</param>
+        public void WearOutfit(List<InventoryBase> ibs)
+        {
+            WearOutfit(ibs, true);
+        }
+        
+        /// <summary>
+        /// Replace the current outfit with a list of wearables and set appearance
+        /// </summary>
+        /// <param name="ibs">List of wearables that define the new outfit</param>
+        /// <param name="bake">Whether to bake textures for the avatar or not</param>
+        public void WearOutfit(List<InventoryBase> ibs, bool bake)
+        {
+            _wearParams = new WearParams(ibs, bake);
+            Thread appearanceThread = new Thread(new ThreadStart(StartWearOutfit));
+            appearanceThread.Start();
+        }
+
+        private WearParams _wearParams;
+        private void StartWearOutfit()
+        {
+            List<InventoryBase> ibs = (List<InventoryBase>)_wearParams.Param;
+            List<InventoryWearable> wearables = new List<InventoryWearable>();
+            List<InventoryBase> attachments = new List<InventoryBase>();
+
+            foreach (InventoryBase ib in ibs)
+            {
+                if (ib is InventoryWearable)
+                    wearables.Add((InventoryWearable)ib);
+                else if (ib is InventoryAttachment || ib is InventoryObject)
+                    attachments.Add(ib);
+            }
+
+
+            SendAgentWearablesRequest();
+            WearablesRequestEvent.WaitOne();
+            ReplaceOutfitWearables(wearables);
+            UpdateAppearanceFromWearables(_wearParams.Bake);
+            AddAttachments(attachments, true);
+        }
+
+        /// <summary>
+        /// Replace the current outfit with a folder and set appearance
+        /// </summary>
+        /// <param name="folder">UUID of the inventory folder to wear</param>
+        public void WearOutfit(UUID folder)
+        {
+            WearOutfit(folder, true);
+        }
+
+        /// <summary>
+        /// Replace the current outfit with a folder and set appearance
+        /// </summary>
+        /// <param name="path">Inventory path of the folder to wear</param>
+        public void WearOutfit(string[] path)
+        {
+            WearOutfit(path, true);
+        }
+
+        /// <summary>
+        /// Replace the current outfit with a folder and set appearance
+        /// </summary>
+        /// <param name="folder">Folder containing the new outfit</param>
+        /// <param name="bake">Whether to bake the avatar textures or not</param>
+        public void WearOutfit(UUID folder, bool bake)
+        {
+            _wearOutfitParams = new WearParams(folder, bake);
+            Thread appearanceThread = new Thread(new ThreadStart(StartWearOutfitFolder));
+            appearanceThread.Start();
+        }
+
+        /// <summary>
+        /// Replace the current outfit with a folder and set appearance
+        /// </summary>
+        /// <param name="path">Path of folder containing the new outfit</param>
+        /// <param name="bake">Whether to bake the avatar textures or not</param>
+        public void WearOutfit(string[] path, bool bake)
+        {
+            _wearOutfitParams = new WearParams(path, bake);
+            Thread appearanceThread = new Thread(new ThreadStart(StartWearOutfitFolder));
+            appearanceThread.Start();
+        }
+
+        public void WearOutfit(InventoryFolder folder, bool bake)
+        {
+            _wearOutfitParams = new WearParams(folder, bake);
+            Thread appearanceThread = new Thread(new ThreadStart(StartWearOutfitFolder));
+            appearanceThread.Start();
+        }
+
+        private void StartWearOutfitFolder()
+        {
+            SendAgentWearablesRequest(); // request current wearables async
+            List<InventoryWearable> wearables;
+            List<InventoryBase> attachments;
+
+            if (!GetFolderWearables(_wearOutfitParams.Param, out wearables, out attachments)) // get wearables in outfit folder
+                return; // TODO: this error condition should be passed back to the client somehow
+
+            WearablesRequestEvent.WaitOne(); // wait for current wearables
+            ReplaceOutfitWearables(wearables); // replace current wearables with outfit folder
+            UpdateAppearanceFromWearables(_wearOutfitParams.Bake);
+            AddAttachments(attachments, true);
+        }
+
+        private bool GetFolderWearables(object _folder, out List<InventoryWearable> wearables, out List<InventoryBase> attachments)
+        {
+            UUID folder;
+            wearables = null;
+            attachments = null;
+
+            if (_folder.GetType() == typeof(string[]))
+            {
+                string[] path = (string[])_folder;
+
+                folder = Client.Inventory.FindObjectByPath(
+                    Client.Inventory.Store.RootFolder.UUID, Client.Self.AgentID, String.Join("/", path), 1000 * 20);
+
+                if (folder == UUID.Zero)
+                {
+                    Logger.Log("Outfit path " + path + " not found", Helpers.LogLevel.Error, Client);
+                    return false;
+                }
+            }
+            else
+                folder = (UUID)_folder;
+
+            wearables = new List<InventoryWearable>();
+            attachments = new List<InventoryBase>();
+            List<InventoryBase> objects = Client.Inventory.FolderContents(folder, Client.Self.AgentID,
+                false, true, InventorySortOrder.ByName, 1000 * 20);
+
+            if (objects != null)
+            {
+                foreach (InventoryBase ib in objects)
+                {
+                    if (ib is InventoryWearable)
+                    {
+                        Logger.DebugLog("Adding wearable " + ib.Name, Client);
+                        wearables.Add((InventoryWearable)ib);
+                    }
+                    else if (ib is InventoryAttachment)
+                    {
+                        Logger.DebugLog("Adding attachment (attachment) " + ib.Name, Client);
+                        attachments.Add(ib);
+                    }
+                    else if (ib is InventoryObject)
+                    {
+                        Logger.DebugLog("Adding attachment (object) " + ib.Name, Client);
+                        attachments.Add(ib);
+                    }
+                    else
+                    {
+                        Logger.DebugLog("Ignoring inventory item " + ib.Name, Client);
+                    }
+                }
+            }
+            else
+            {
+                Logger.Log("Failed to download folder contents of + " + folder.ToString(),
+                    Helpers.LogLevel.Error, Client);
+                return false;
+            }
+
+            return true;
+        }
+
+        // this method will download the assets for all inventory items in iws
+        private void ReplaceOutfitWearables(List<InventoryWearable> iws)
+        {
+            lock (Wearables.Dictionary)
+            {
+                Dictionary<WearableType, WearableData> preserve = new Dictionary<WearableType,WearableData>();
+                
+                foreach (KeyValuePair<WearableType,WearableData> kvp in Wearables.Dictionary)
+                {
+                    if (kvp.Value.Item.AssetType == AssetType.Bodypart)
+                            preserve.Add(kvp.Key, kvp.Value);
+                }
+
+                Wearables.Dictionary = preserve;
+            
+                foreach (InventoryWearable iw in iws)
+                {
+                    WearableData wd = new WearableData();
+                    wd.Item = iw; 
+                    Wearables.Dictionary[wd.Item.WearableType] = wd;
+                }
+            }
+        }
+
+        /// <summary>
+        /// Adds a list of attachments to avatar
+        /// </summary>
+        /// <param name="attachments">A List containing the attachments to add</param>
+        /// <param name="removeExistingFirst">If true, tells simulator to remove existing attachment
+        /// first</param>
+        public void AddAttachments(List<InventoryBase> attachments, bool removeExistingFirst)
+        {
+            // FIXME: Obey this
+            //const int OBJECTS_PER_PACKET = 4;
+
+            // Use RezMultipleAttachmentsFromInv  to clear out current attachments, and attach new ones
+            RezMultipleAttachmentsFromInvPacket attachmentsPacket = new RezMultipleAttachmentsFromInvPacket();
+            attachmentsPacket.AgentData.AgentID = Client.Self.AgentID;
+            attachmentsPacket.AgentData.SessionID = Client.Self.SessionID;
+
+            attachmentsPacket.HeaderData.CompoundMsgID = UUID.Random();
+            attachmentsPacket.HeaderData.FirstDetachAll = true;
+            attachmentsPacket.HeaderData.TotalObjects = (byte)attachments.Count;
+
+            attachmentsPacket.ObjectData = new RezMultipleAttachmentsFromInvPacket.ObjectDataBlock[attachments.Count];
+            for (int i = 0; i < attachments.Count; i++)
+            {
+                if (attachments[i] is InventoryAttachment)
+                {
+                    InventoryAttachment attachment = (InventoryAttachment)attachments[i];
+                    attachmentsPacket.ObjectData[i] = new RezMultipleAttachmentsFromInvPacket.ObjectDataBlock();
+                    attachmentsPacket.ObjectData[i].AttachmentPt = 0;
+                    attachmentsPacket.ObjectData[i].EveryoneMask = (uint)attachment.Permissions.EveryoneMask;
+                    attachmentsPacket.ObjectData[i].GroupMask = (uint)attachment.Permissions.GroupMask;
+                    attachmentsPacket.ObjectData[i].ItemFlags = (uint)attachment.Flags;
+                    attachmentsPacket.ObjectData[i].ItemID = attachment.UUID;
+                    attachmentsPacket.ObjectData[i].Name = Utils.StringToBytes(attachment.Name);
+                    attachmentsPacket.ObjectData[i].Description = Utils.StringToBytes(attachment.Description);
+                    attachmentsPacket.ObjectData[i].NextOwnerMask = (uint)attachment.Permissions.NextOwnerMask;
+                    attachmentsPacket.ObjectData[i].OwnerID = attachment.OwnerID;
+                }
+                else if (attachments[i] is InventoryObject)
+                {
+                    InventoryObject attachment = (InventoryObject)attachments[i];
+                    attachmentsPacket.ObjectData[i] = new RezMultipleAttachmentsFromInvPacket.ObjectDataBlock();
+                    attachmentsPacket.ObjectData[i].AttachmentPt = 0;
+                    attachmentsPacket.ObjectData[i].EveryoneMask = (uint)attachment.Permissions.EveryoneMask;
+                    attachmentsPacket.ObjectData[i].GroupMask = (uint)attachment.Permissions.GroupMask;
+                    attachmentsPacket.ObjectData[i].ItemFlags = (uint)attachment.Flags;
+                    attachmentsPacket.ObjectData[i].ItemID = attachment.UUID;
+                    attachmentsPacket.ObjectData[i].Name = Utils.StringToBytes(attachment.Name);
+                    attachmentsPacket.ObjectData[i].Description = Utils.StringToBytes(attachment.Description);
+                    attachmentsPacket.ObjectData[i].NextOwnerMask = (uint)attachment.Permissions.NextOwnerMask;
+                    attachmentsPacket.ObjectData[i].OwnerID = attachment.OwnerID;
+                }
+                else
+                {
+                    Logger.Log("Cannot attach inventory item of type " + attachments[i].GetType().ToString(),
+                        Helpers.LogLevel.Warning, Client);
+                }
+            }
+
+            Client.Network.SendPacket(attachmentsPacket);
+        }
+
+        /// <summary>
+        /// Attach an item to an avatar at a specific attach point
+        /// </summary>
+        /// <param name="item">A <seealso cref="OpenMetaverse.InventoryItem"/> to attach</param>
+        /// <param name="attachPoint">the <seealso cref="OpenMetaverse.AttachmentPoint"/> on the avatar 
+        /// to attach the item to</param>
+        public void Attach(InventoryItem item, AttachmentPoint attachPoint)
+        {
+            Attach(item.UUID, item.OwnerID, item.Name, item.Description, item.Permissions, item.Flags, 
+                attachPoint);
+        }
+
+        /// <summary>
+        /// Attach an item to an avatar specifying attachment details
+        /// </summary>
+        /// <param name="itemID">The <seealso cref="OpenMetaverse.UUID"/> of the item to attach</param>
+        /// <param name="ownerID">The <seealso cref="OpenMetaverse.UUID"/> attachments owner</param>
+        /// <param name="name">The name of the attachment</param>
+        /// <param name="description">The description of the attahment</param>
+        /// <param name="perms">The <seealso cref="OpenMetaverse.Permissions"/> to apply when attached</param>
+        /// <param name="itemFlags">The <seealso cref="OpenMetaverse.InventoryItemFlags"/> of the attachment</param>
+        /// <param name="attachPoint">the <seealso cref="OpenMetaverse.AttachmentPoint"/> on the avatar 
+        /// to attach the item to</param>
+        public void Attach(UUID itemID, UUID ownerID, string name, string description,
+            Permissions perms, uint itemFlags, AttachmentPoint attachPoint)
+        {
+            // TODO: At some point it might be beneficial to have AppearanceManager track what we
+            // are currently wearing for attachments to make enumeration and detachment easier
+
+            RezSingleAttachmentFromInvPacket attach = new RezSingleAttachmentFromInvPacket();
+
+            attach.AgentData.AgentID = Client.Self.AgentID;
+            attach.AgentData.SessionID = Client.Self.SessionID;
+
+            attach.ObjectData.AttachmentPt = (byte)attachPoint;
+            attach.ObjectData.Description = Utils.StringToBytes(description);
+            attach.ObjectData.EveryoneMask = (uint)perms.EveryoneMask;
+            attach.ObjectData.GroupMask = (uint)perms.GroupMask;
+            attach.ObjectData.ItemFlags = itemFlags;
+            attach.ObjectData.ItemID = itemID;
+            attach.ObjectData.Name = Utils.StringToBytes(name);
+            attach.ObjectData.NextOwnerMask = (uint)perms.NextOwnerMask;
+            attach.ObjectData.OwnerID = ownerID;
+
+            Client.Network.SendPacket(attach);
+        }
+
+        /// <summary>
+        /// Detach an item from avatar using an <seealso cref="OpenMetaverse.InventoryItem"/> object
+        /// </summary>
+        /// <param name="item">An <seealso cref="OpenMetaverse.InventoryItem"/> object</param>
+        public void Detach(InventoryItem item)
+        {
+            Detach(item.UUID); 
+        }
+
+        /// <summary>
+        /// Detach an Item from avatar by items <seealso cref="OpenMetaverse.UUID"/>
+        /// </summary>
+        /// <param name="itemID">The items ID to detach</param>
+        public void Detach(UUID itemID)
+        {
+            DetachAttachmentIntoInvPacket detach = new DetachAttachmentIntoInvPacket();
+            detach.ObjectData.AgentID = Client.Self.AgentID;
+            detach.ObjectData.ItemID = itemID;
+
+            Client.Network.SendPacket(detach);
+        }
+
+
+        private void UpdateAppearanceFromWearables(bool bake)
+        {
+            lock (AgentTextures)
+            {
+                for (int i = 0; i < AgentTextures.Length; i++)
+                    AgentTextures[i] = UUID.Zero;
+            }
+
+            // Register an asset download callback to get wearable data
+            AssetManager.AssetReceivedCallback assetCallback = new AssetManager.AssetReceivedCallback(Assets_OnAssetReceived);
+            AssetManager.ImageReceivedCallback imageCallback = new AssetManager.ImageReceivedCallback(Assets_OnImageReceived);
+            AssetManager.AssetUploadedCallback uploadCallback = new AssetManager.AssetUploadedCallback(Assets_OnAssetUploaded);
+            Assets.OnAssetReceived += assetCallback;
+            Assets.OnImageReceived += imageCallback;
+            Assets.OnAssetUploaded += uploadCallback;
+
+            // Download assets for what we are wearing and fill in AgentTextures
+            DownloadWearableAssets();
+            WearablesDownloadedEvent.WaitOne();
+
+            // Unregister the asset download callback
+            Assets.OnAssetReceived -= assetCallback;
+
+            // Check if anything needs to be rebaked
+            if (bake) RequestCachedBakes();
+
+            // Tell the sim what we are wearing
+            SendAgentIsNowWearing();
+
+            // Wait for cached layer check to finish
+            if (bake) CachedResponseEvent.WaitOne();
+
+            // Unregister the image download and asset upload callbacks
+            Assets.OnImageReceived -= imageCallback;
+            Assets.OnAssetUploaded -= uploadCallback;
+
+            Logger.DebugLog("CachedResponseEvent completed", Client);
+
+            #region Send Appearance
+
+            Primitive.TextureEntry te = null;
+
+            ObjectManager.NewAvatarCallback updateCallback =
+                delegate(Simulator simulator, Avatar avatar, ulong regionHandle, ushort timeDilation)
+                {
+                    if (avatar.LocalID == Client.Self.LocalID)
+                    {
+                        if (avatar.Textures.FaceTextures != null)
+                        {
+                            bool match = true;
+
+                            for (uint i = 0; i < AgentTextures.Length; i++)
+                            {
+                                Primitive.TextureEntryFace face = avatar.Textures.FaceTextures[i];
+
+                                if (face == null)
+                                {
+                                    // If the texture is UUID.Zero the face should be null
+                                    if (AgentTextures[i] != UUID.Zero)
+                                    {
+                                        match = false;
+                                        break;
+                                    }
+                                }
+                                else if (face.TextureID != AgentTextures[i])
+                                {
+                                    match = false;
+                                    break;
+                                }
+                            }
+
+                            if (!match)
+                                Logger.Log("TextureEntry mismatch after updating our appearance", Helpers.LogLevel.Warning, Client);
+
+                            te = avatar.Textures;
+                            UpdateEvent.Set();
+                        }
+                        else
+                        {
+                            Logger.Log("Received an update for our avatar with a null FaceTextures array",
+                                Helpers.LogLevel.Warning, Client);
+                        }
+                    }
+                };
+            Client.Objects.OnNewAvatar += updateCallback;
+
+            // Send all of the visual params and textures for our agent
+            SendAgentSetAppearance();
+
+            // Wait for the ObjectUpdate to come in for our avatar after changing appearance
+            if (UpdateEvent.WaitOne(1000 * 60, false))
+            {
+                if (OnAppearanceUpdated != null)
+                {
+                    try { OnAppearanceUpdated(te); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+            }
+            else
+            {
+                Logger.Log("Timed out waiting for our appearance to update on the simulator", Helpers.LogLevel.Warning, Client);
+            }
+
+            Client.Objects.OnNewAvatar -= updateCallback;
+
+            #endregion Send Appearance
+        }
+
+        /// <summary>
+        /// Build hashes out of the texture assetIDs for each baking layer to
+        /// ask the simulator whether it has cached copies of each baked texture
+        /// </summary>
+        public void RequestCachedBakes()
+        {
+            Logger.DebugLog("RequestCachedBakes()", Client);
+            
+            List<KeyValuePair<int, UUID>> hashes = new List<KeyValuePair<int,UUID>>();
+
+            AgentCachedTexturePacket cache = new AgentCachedTexturePacket();
+            cache.AgentData.AgentID = Client.Self.AgentID;
+            cache.AgentData.SessionID = Client.Self.SessionID;
+            cache.AgentData.SerialNum = CacheCheckSerialNum;
+
+            // Build hashes for each of the bake layers from the individual components
+            for (int bakedIndex = 0; bakedIndex < BAKED_TEXTURE_COUNT; bakedIndex++)
+            {
+                // Don't do a cache request for a skirt bake if we're not wearing a skirt
+                if (bakedIndex == (int)BakeType.Skirt && 
+                    (!Wearables.ContainsKey(WearableType.Skirt) || Wearables.Dictionary[WearableType.Skirt].Asset.AssetID == UUID.Zero))
+                    continue;
+
+                UUID hash = new UUID();
+
+                for (int wearableIndex = 0; wearableIndex < WEARABLES_PER_LAYER; wearableIndex++)
+                {
+                    WearableType type = WEARABLE_BAKE_MAP[bakedIndex][wearableIndex];
+                    UUID assetID = GetWearableAsset(type);
+
+                    // Build a hash of all the texture asset IDs in this baking layer
+                    if (assetID != UUID.Zero) hash ^= assetID;
+                }
+
+                if (hash != UUID.Zero)
+                {
+                    // Hash with our secret value for this baked layer
+                    hash ^= BAKED_TEXTURE_HASH[bakedIndex];
+
+                    // Add this to the list of hashes to send out
+                    hashes.Add(new KeyValuePair<int, UUID>(bakedIndex, hash));
+                }
+            }
+
+            // Only send the packet out if there's something to check
+            if (hashes.Count > 0)
+            {
+                cache.WearableData = new AgentCachedTexturePacket.WearableDataBlock[hashes.Count];
+
+                for (int i = 0; i < hashes.Count; i++)
+                {
+                    cache.WearableData[i] = new AgentCachedTexturePacket.WearableDataBlock();
+                    cache.WearableData[i].TextureIndex = (byte)hashes[i].Key;
+                    cache.WearableData[i].ID = hashes[i].Value;
+
+                    Logger.DebugLog("Checking cache for index " + cache.WearableData[i].TextureIndex +
+                        ", ID: " + cache.WearableData[i].ID, Client);
+                }
+
+                // Increment our serial number for this packet
+                CacheCheckSerialNum++;
+
+                // Send it out
+                Client.Network.SendPacket(cache);
+            }
+        }
+
+        /// <summary>
+        /// Ask the server what textures our avatar is currently wearing
+        /// </summary>
+        public void SendAgentWearablesRequest()
+        {
+            AgentWearablesRequestPacket request = new AgentWearablesRequestPacket();
+            request.AgentData.AgentID = Client.Self.AgentID;
+            request.AgentData.SessionID = Client.Self.SessionID;
+
+            Client.Network.SendPacket(request);
+        }
+
+        private void AgentWearablesUpdateHandler(Packet packet, Simulator simulator)
+        {
+            // Lock to prevent a race condition with multiple AgentWearables packets
+            lock (WearablesRequestEvent)
+            {
+                AgentWearablesUpdatePacket update = (AgentWearablesUpdatePacket)packet;
+
+                // Reset the Wearables collection
+                lock (Wearables.Dictionary) Wearables.Dictionary.Clear();
+
+                for (int i = 0; i < update.WearableData.Length; i++)
+                {
+                    if (update.WearableData[i].AssetID != UUID.Zero)
+                    {
+                        WearableType type = (WearableType)update.WearableData[i].WearableType;
+                        WearableData data = new WearableData();
+                        data.Item = new InventoryWearable(update.WearableData[i].ItemID);
+                        data.Item.WearableType = type;
+                        data.Item.AssetType = WearableTypeToAssetType(type);
+                        data.Item.AssetUUID = update.WearableData[i].AssetID;
+
+                        // Add this wearable to our collection
+                        lock (Wearables.Dictionary) Wearables.Dictionary[type] = data;
+                    }
+                }
+            }
+
+            WearablesRequestEvent.Set();
+        }
+
+        private void SendAgentSetAppearance()
+        {
+            AgentSetAppearancePacket set = new AgentSetAppearancePacket();
+            set.AgentData.AgentID = Client.Self.AgentID;
+            set.AgentData.SessionID = Client.Self.SessionID;
+            set.AgentData.SerialNum = SetAppearanceSerialNum++;
+            set.VisualParam = new AgentSetAppearancePacket.VisualParamBlock[218];
+
+            float AgentSizeVPHeight = 0.0f;
+            float AgentSizeVPHeelHeight = 0.0f;
+            float AgentSizeVPPlatformHeight = 0.0f;
+            float AgentSizeVPHeadSize = 0.5f;
+            float AgentSizeVPLegLength = 0.0f;
+            float AgentSizeVPNeckLength = 0.0f;
+            float AgentSizeVPHipLength = 0.0f;
+
+            lock (Wearables.Dictionary)
+            {
+                // Only for debugging output
+                int count = 0, vpIndex = 0;
+
+                // Build the visual param array
+                foreach (KeyValuePair<int, VisualParam> kvp in VisualParams.Params)
+                {
+                    VisualParam vp = kvp.Value;
+
+                    // Only Group-0 parameters are sent in AgentSetAppearance packets
+                    if (vp.Group == 0)
+                    {
+                        set.VisualParam[vpIndex] = new AgentSetAppearancePacket.VisualParamBlock();
+
+                        // Try and find this value in our collection of downloaded wearables
+                        foreach (WearableData data in Wearables.Dictionary.Values)
+                        {
+                            if (data.Asset != null && data.Asset.Params.ContainsKey(vp.ParamID))
+                            {
+                                set.VisualParam[vpIndex].ParamValue = Utils.FloatToByte(data.Asset.Params[vp.ParamID], vp.MinValue, vp.MaxValue);
+                                count++;
+
+                                switch (vp.ParamID)
+                                {
+                                    case 33:
+                                        AgentSizeVPHeight = data.Asset.Params[vp.ParamID];
+                                        break;
+                                    case 198:
+                                        AgentSizeVPHeelHeight = data.Asset.Params[vp.ParamID];
+                                        break;
+                                    case 503:
+                                        AgentSizeVPPlatformHeight = data.Asset.Params[vp.ParamID];
+                                        break;
+                                    case 682:
+                                        AgentSizeVPHeadSize = data.Asset.Params[vp.ParamID];
+                                        break;
+                                    case 692:
+                                        AgentSizeVPLegLength = data.Asset.Params[vp.ParamID];
+                                        break;
+                                    case 756:
+                                        AgentSizeVPNeckLength = data.Asset.Params[vp.ParamID];
+                                        break;
+                                    case 842:
+                                        AgentSizeVPHipLength = data.Asset.Params[vp.ParamID];
+                                        break;
+                                }
+                                break;
+                            }
+                        }
+
+                        ++vpIndex;
+                    }
+                }
+
+                // Build the texture entry for our agent
+                Primitive.TextureEntry te = new Primitive.TextureEntry(DEFAULT_AVATAR_TEXTURE);
+
+                // Put our AgentTextures array in to TextureEntry
+                lock (AgentTextures)
+                {
+                    for (uint i = 0; i < AgentTextures.Length; i++)
+                    {
+                        if (AgentTextures[i] != UUID.Zero)
+                        {
+                            Primitive.TextureEntryFace face = te.CreateFace(i);
+                            face.TextureID = AgentTextures[i];
+                        }
+                    }
+                }
+
+                foreach (WearableData data in Wearables.Dictionary.Values)
+                {
+                    if (data.Asset != null)
+                    {
+                        foreach (KeyValuePair<TextureIndex, UUID> texture in data.Asset.Textures)
+                        {
+                            Primitive.TextureEntryFace face = te.CreateFace((uint)texture.Key);
+                            face.TextureID = texture.Value;
+
+                            Logger.DebugLog("Setting agent texture " + ((TextureIndex)texture.Key).ToString() + " to " +
+                                texture.Value.ToString(), Client);
+                        }
+                    }
+                }
+
+                // Set the packet TextureEntry
+                set.ObjectData.TextureEntry = te.ToBytes();
+            }
+
+            // FIXME: Our hackish algorithm is making squished avatars. See
+            // http://www.OpenMetaverse.org/wiki/Agent_Size for discussion of the correct algorithm
+            //float height = Utils.ByteToFloat(set.VisualParam[33].ParamValue, VisualParams.Params[33].MinValue,
+            //    VisualParams.Params[33].MaxValue);
+
+            // Takes into account the Shoe Heel/Platform offsets but not the Head Size Offset.  But seems to work.
+            double AgentSizeBase = 1.706;
+
+            // The calculation for the Head Size scalar may be incorrect.  But seems to work.
+            double AgentHeight = AgentSizeBase + (AgentSizeVPLegLength * .1918) + (AgentSizeVPHipLength * .0375) +
+                (AgentSizeVPHeight * .12022) + (AgentSizeVPHeadSize * .01117) + (AgentSizeVPNeckLength * .038) +
+                (AgentSizeVPHeelHeight * .08) + (AgentSizeVPPlatformHeight * .07);
+
+            set.AgentData.Size = new Vector3(0.45f, 0.6f, (float)AgentHeight);
+
+            // TODO: Account for not having all the textures baked yet
+            set.WearableData = new AgentSetAppearancePacket.WearableDataBlock[BAKED_TEXTURE_COUNT];
+
+            // Build hashes for each of the bake layers from the individual components
+            for (int bakedIndex = 0; bakedIndex < BAKED_TEXTURE_COUNT; bakedIndex++)
+            {
+                UUID hash = new UUID();
+
+                for (int wearableIndex = 0; wearableIndex < WEARABLES_PER_LAYER; wearableIndex++)
+                {
+                    WearableType type = WEARABLE_BAKE_MAP[bakedIndex][wearableIndex];
+                    UUID assetID = GetWearableAsset(type);
+
+                    // Build a hash of all the texture asset IDs in this baking layer
+                    if (assetID != UUID.Zero) hash ^= assetID;
+                }
+
+                if (hash != UUID.Zero)
+                {
+                    // Hash with our secret value for this baked layer
+                    hash ^= BAKED_TEXTURE_HASH[bakedIndex];
+                }
+
+                // Tell the server what cached texture assetID to use for each bake layer
+                set.WearableData[bakedIndex] = new AgentSetAppearancePacket.WearableDataBlock();
+                set.WearableData[bakedIndex].TextureIndex = (byte)bakedIndex;
+                set.WearableData[bakedIndex].CacheID = hash;
+            }
+
+            // Finally, send the packet
+            Client.Network.SendPacket(set);
+        }
+
+
+        private void SendAgentIsNowWearing()
+        {
+            Logger.DebugLog("SendAgentIsNowWearing()", Client);
+
+            AgentIsNowWearingPacket wearing = new AgentIsNowWearingPacket();
+            wearing.AgentData.AgentID = Client.Self.AgentID;
+            wearing.AgentData.SessionID = Client.Self.SessionID;
+            wearing.WearableData = new AgentIsNowWearingPacket.WearableDataBlock[WEARABLE_COUNT];
+
+            for (int i = 0; i < WEARABLE_COUNT; i++)
+            {
+                WearableType type = (WearableType)i;
+                wearing.WearableData[i] = new AgentIsNowWearingPacket.WearableDataBlock();
+                wearing.WearableData[i].WearableType = (byte)i;
+
+                if (Wearables.ContainsKey(type))
+                    wearing.WearableData[i].ItemID = Wearables.Dictionary[type].Item.UUID;
+                else
+                    wearing.WearableData[i].ItemID = UUID.Zero;
+            }
+
+            Client.Network.SendPacket(wearing);
+        }
+
+        private TextureIndex BakeTypeToAgentTextureIndex(BakeType index)
+        {
+            switch (index)
+            {
+                case BakeType.Head:
+                    return TextureIndex.HeadBaked;
+                case BakeType.UpperBody:
+                    return TextureIndex.UpperBaked;
+                case BakeType.LowerBody:
+                    return TextureIndex.LowerBaked;
+                case BakeType.Eyes:
+                    return TextureIndex.EyesBaked;
+                case BakeType.Skirt:
+                    return TextureIndex.SkirtBaked;
+                default:
+                    return TextureIndex.Unknown;
+            }
+        }
+
+        private void DownloadWearableAssets()
+        {
+            foreach (KeyValuePair<WearableType, WearableData> kvp in Wearables.Dictionary)
+            {
+                Logger.DebugLog("Requesting asset for wearable item " + kvp.Value.Item.WearableType + " (" + kvp.Value.Item.AssetUUID + ")", Client);
+                AssetDownloads.Enqueue(new PendingAssetDownload(kvp.Value.Item.AssetUUID, kvp.Value.Item.AssetType));
+            }
+
+            if (AssetDownloads.Count > 0)
+            {
+                PendingAssetDownload pad = AssetDownloads.Dequeue();
+                Assets.RequestAsset(pad.Id, pad.Type, true);
+            }
+        }
+
+        private void UploadBake(Baker bake)
+        {
+            if(bake.BakedTexture.AssetID==UUID.Zero)
+            {
+                Logger.Log("UploadBake(): Warning possible Linden Default textures in use, skipping this baked upload",Helpers.LogLevel.Warning, Client);
+                return;
+            }
+
+            lock (PendingUploads)
+            {
+                if(PendingUploads.ContainsKey(bake.BakedTexture.AssetID))
+                {
+                    Logger.Log("UploadBake(): Skipping Asset id "+bake.BakedTexture.AssetID.ToString()+" Already in progress",Helpers.LogLevel.Info, Client);
+                    return;
+                }
+
+             // Add it to a pending uploads list
+             PendingUploads.Add(bake.BakedTexture.AssetID, BakeTypeToAgentTextureIndex(bake.BakeType));
+             }
+
+            // Upload the completed layer data
+            Assets.RequestUpload(bake.BakedTexture, true);
+
+            Logger.DebugLog(String.Format("Bake {0} completed. Uploading asset {1}", bake.BakeType,
+                bake.BakedTexture.AssetID.ToString()), Client);
+
+        }
+
+        private int AddImageDownload(TextureIndex index)
+        {
+            UUID image = AgentTextures[(int)index];
+
+            if (image != UUID.Zero)
+            {
+                if (!ImageDownloads.ContainsKey(image))
+                {
+                    Logger.DebugLog("Downloading layer " + index.ToString(), Client);
+                    ImageDownloads.Add(image, index);
+                }
+
+                return 1;
+            }
+
+            return 0;
+        }
+
+        #region Callbacks
+
+        private void AgentCachedTextureResponseHandler(Packet packet, Simulator simulator)
+        {
+            Logger.DebugLog("AgentCachedTextureResponseHandler()", Client);
+            
+            AgentCachedTextureResponsePacket response = (AgentCachedTextureResponsePacket)packet;
+            Dictionary<int, float> paramValues = new Dictionary<int, float>(VisualParams.Params.Count);
+
+            // Build a dictionary of appearance parameter indices and values from the wearables
+            foreach (KeyValuePair<int,VisualParam> kvp in VisualParams.Params)
+            {
+                // Only Group-0 parameters are sent in AgentSetAppearance packets
+                if (kvp.Value.Group == 0)
+                {
+                    bool found = false;
+                    VisualParam vp = kvp.Value;
+
+                    // Try and find this value in our collection of downloaded wearables
+                    foreach (WearableData data in Wearables.Dictionary.Values)
+                    {
+                        if (data.Asset.Params.ContainsKey(vp.ParamID))
+                        {
+                            paramValues.Add(vp.ParamID, data.Asset.Params[vp.ParamID]);
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    // Use a default value if we don't have one set for it
+                    if (!found) paramValues.Add(vp.ParamID, vp.DefaultValue);
+                }
+            }
+
+            lock (AgentTextures)
+            {
+                foreach (AgentCachedTextureResponsePacket.WearableDataBlock block in response.WearableData)
+                {
+                    // For each missing element we need to bake our own texture
+                    Logger.DebugLog("Cache response, index: " + block.TextureIndex + ", ID: " +
+                        block.TextureID.ToString(), Client);
+
+                    // FIXME: Use this. Right now we treat baked images on other sims as if they were missing
+                    string host = Utils.BytesToString(block.HostName);
+                    if (host.Length > 0) Logger.DebugLog("Cached bake exists on foreign host " + host, Client);
+
+                    BakeType bakeType = (BakeType)block.TextureIndex;
+                    
+                    // Convert the baked index to an AgentTexture index
+                    if (block.TextureID != UUID.Zero && host.Length == 0)
+                    {
+                        TextureIndex index = BakeTypeToAgentTextureIndex(bakeType);
+                        AgentTextures[(int)index] = block.TextureID;
+                    }
+                    else
+                    {
+                        int imageCount = 0;
+
+                        // Download all of the images in this layer
+                        switch (bakeType)
+                        {
+                            case BakeType.Head:
+                                lock (ImageDownloads)
+                                {
+                                    imageCount += AddImageDownload(TextureIndex.HeadBodypaint);
+                                    //imageCount += AddImageDownload(TextureIndex.Hair);
+                                }
+                                break;
+                            case BakeType.UpperBody:
+                                lock (ImageDownloads)
+                                {
+                                    imageCount += AddImageDownload(TextureIndex.UpperBodypaint);
+                                    imageCount += AddImageDownload(TextureIndex.UpperGloves);
+                                    imageCount += AddImageDownload(TextureIndex.UpperUndershirt);
+                                    imageCount += AddImageDownload(TextureIndex.UpperShirt);
+                                    imageCount += AddImageDownload(TextureIndex.UpperJacket);
+                                }
+                                break;
+                            case BakeType.LowerBody:
+                                lock (ImageDownloads)
+                                {
+                                    imageCount += AddImageDownload(TextureIndex.LowerBodypaint);
+                                    imageCount += AddImageDownload(TextureIndex.LowerUnderpants);
+                                    imageCount += AddImageDownload(TextureIndex.LowerSocks);
+                                    imageCount += AddImageDownload(TextureIndex.LowerShoes);
+                                    imageCount += AddImageDownload(TextureIndex.LowerPants);
+                                    imageCount += AddImageDownload(TextureIndex.LowerJacket);
+                                }
+                                break;
+                            case BakeType.Eyes:
+                                lock (ImageDownloads)
+                                {
+                                    imageCount += AddImageDownload(TextureIndex.EyesIris);
+                                }
+                                break;
+                            case BakeType.Skirt:
+                                if (Wearables.ContainsKey(WearableType.Skirt))
+                                {
+                                    lock (ImageDownloads)
+                                    {
+                                        imageCount += AddImageDownload(TextureIndex.Skirt);
+                                    }
+                                }
+                                break;
+                            default:
+                                Logger.Log("Unknown BakeType " + block.TextureIndex, Helpers.LogLevel.Warning, Client);
+                                break;
+                        }
+
+                        if (!PendingBakes.ContainsKey(bakeType))
+                        {
+                            Logger.DebugLog("Initializing " + bakeType.ToString() + " bake with " + imageCount + " textures", Client);
+
+                            if (imageCount == 0)
+                            {
+                                // if there are no textures to download, we can bake right away and start the upload
+                                Baker bake = new Baker(Client, bakeType, 0, paramValues);
+                                UploadBake(bake);
+                            }
+                            else
+                            {
+                                lock (PendingBakes)
+                                    PendingBakes.Add(bakeType, new Baker(Client, bakeType, imageCount, paramValues));
+                            }
+                        }
+                        else if (!PendingBakes.ContainsKey(bakeType))
+                        {
+                            Logger.Log("No cached bake for " + bakeType.ToString() + " and no textures for that " +
+                                "layer, this is an unhandled case", Helpers.LogLevel.Error, Client);
+                        }
+                    }
+                }
+            }
+
+            if (ImageDownloads.Count == 0)
+            {
+                // No pending downloads for baking, we're done
+                CachedResponseEvent.Set();
+            }
+            else
+            {
+                lock (ImageDownloads)
+                {
+                    List<UUID> imgKeys = new List<UUID>(ImageDownloads.Keys);
+                    foreach (UUID image in imgKeys)
+                    {
+                        // Download all the images we need for baking
+                        Assets.RequestImage(image, ImageType.Normal, 1013000.0f, 0, 0);
+                    }
+                }
+            }
+        }
+
+        private void Assets_OnAssetReceived(AssetDownload download, Asset asset)
+        {
+            lock (Wearables.Dictionary)
+            {
+                // Check if this is a wearable we were waiting on
+                foreach (KeyValuePair<WearableType,WearableData> kvp in Wearables.Dictionary)
+                {
+                    if (kvp.Value.Item.AssetUUID == download.AssetID)
+                    {
+                        // Make sure the download succeeded
+                        if (download.Success)
+                        {
+                            kvp.Value.Asset = (AssetWearable)asset;
+
+                            Logger.DebugLog("Downloaded wearable asset " + kvp.Value.Asset.Name, Client);
+
+                            if (!kvp.Value.Asset.Decode())
+                            {
+                                Logger.Log("Failed to decode asset:" + Environment.NewLine +
+                                    Utils.BytesToString(asset.AssetData), Helpers.LogLevel.Error, Client);
+                            }
+
+                            lock (AgentTextures)
+                            {
+                                foreach (KeyValuePair<AppearanceManager.TextureIndex, UUID> texture in kvp.Value.Asset.Textures)
+                                {
+                                    if (texture.Value != DEFAULT_AVATAR_TEXTURE) // this texture is not meant to be displayed
+                                    {
+                                        Logger.DebugLog("Setting " + texture.Key + " to " + texture.Value, Client);
+                                        AgentTextures[(int)texture.Key] = texture.Value;
+                                    }
+                                }
+                            }
+                        }
+                        else
+                        {
+                            Logger.Log("Wearable " + kvp.Key + "(" + download.AssetID.ToString() + ") failed to download, " +
+                                download.Status.ToString(), Helpers.LogLevel.Warning, Client);
+                        }
+
+                        break;
+                    }
+                }
+            }
+
+            if (AssetDownloads.Count > 0)
+            {
+                // Dowload the next wearable in line
+                PendingAssetDownload pad = AssetDownloads.Dequeue();
+                Assets.RequestAsset(pad.Id, pad.Type, true);
+            }
+            else
+            {
+                // Everything is downloaded
+                if (OnAgentWearables != null)
+                {
+                    try { OnAgentWearables(); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+
+                WearablesDownloadedEvent.Set();
+            }
+        }
+
+        private void Assets_OnImageReceived(ImageDownload image, AssetTexture assetTexture)
+        {
+            lock (ImageDownloads)
+            {
+                if (ImageDownloads.ContainsKey(image.ID))
+                {
+                    ImageDownloads.Remove(image.ID);
+
+                    // NOTE: This image may occupy more than one TextureIndex! We must finish this loop
+                    for (int at = 0; at < AgentTextures.Length; at++)
+                    {
+                        if (AgentTextures[at] == image.ID)
+                        {
+                            TextureIndex index = (TextureIndex)at;
+                            BakeType type = Baker.BakeTypeFor(index);
+
+                            //BinaryWriter writer = new BinaryWriter(File.Create("wearable_" + index.ToString() + "_" + image.ID.ToString() + ".jp2"));
+                            //writer.Write(image.AssetData);
+                            //writer.Close();
+
+                            bool baked = false;
+
+                            if (PendingBakes.ContainsKey(type))
+                            {
+                                if (image.Success)
+                                {
+                                    Logger.DebugLog("Finished downloading texture for " + index.ToString(), Client);
+                                    OpenJPEG.DecodeToImage(image.AssetData, out assetTexture.Image);
+                                    baked = PendingBakes[type].AddTexture(index, assetTexture, false);
+                                }
+                                else
+                                {
+                                    Logger.Log("Texture for " + index.ToString() + " failed to download, " +
+                                        "bake will be incomplete", Helpers.LogLevel.Warning, Client);
+                                    baked = PendingBakes[type].MissingTexture(index);
+                                }
+                            }
+
+                            if (baked)
+                            {
+                                UploadBake(PendingBakes[type]);
+                                PendingBakes.Remove(type);
+                            }
+
+                            if (ImageDownloads.Count == 0 && PendingUploads.Count == 0)
+                            {
+                                // This is a failsafe catch, as the upload completed callback should normally 
+                                // be triggering the event
+                                Logger.DebugLog("No pending downloads or uploads detected in OnImageReceived", Client);
+                                CachedResponseEvent.Set();
+                            }
+                            else
+                            {
+                                Logger.DebugLog("Pending uploads: " + PendingUploads.Count + ", pending downloads: " +
+                                    ImageDownloads.Count, Client);
+                            }
+
+                        }
+                    }
+                }
+                else
+                {
+                    Logger.Log("Received an image download callback for an image we did not request " + image.ID.ToString(),
+                        Helpers.LogLevel.Warning, Client);
+                }
+            }
+        }
+
+        private void Assets_OnAssetUploaded(AssetUpload upload)
+        {
+            lock (PendingUploads)
+            {
+                if (PendingUploads.ContainsKey(upload.AssetID))
+                {
+                    if (upload.Success)
+                    {
+                        // Setup the TextureEntry with the new baked upload
+                        TextureIndex index = PendingUploads[upload.AssetID];
+                        AgentTextures[(int)index] = upload.AssetID;
+
+                        Logger.DebugLog("Upload complete, AgentTextures " + index.ToString() + " set to " + 
+                            upload.AssetID.ToString(), Client);
+                    }
+                    else
+                    {
+                        Logger.Log("Asset upload " + upload.AssetID.ToString() + " failed", 
+                            Helpers.LogLevel.Warning, Client);
+                    }
+
+                    PendingUploads.Remove(upload.AssetID);
+
+                    Logger.DebugLog("Pending uploads: " + PendingUploads.Count + ", pending downloads: " +
+                        ImageDownloads.Count, Client);
+
+                    if (PendingUploads.Count == 0 && ImageDownloads.Count == 0)
+                    {
+                        Logger.DebugLog("All pending image downloads and uploads complete", Client);
+
+                        CachedResponseEvent.Set();
+                    }
+                }
+                else
+                {
+                    // TEMP
+                    Logger.DebugLog("Upload " + upload.AssetID.ToString() + " was not found in PendingUploads", Client);
+                }
+            }
+        }
+
+        /// <summary>
+        /// Terminate any wait handles when the network layer disconnects
+        /// </summary>
+        private void Network_OnDisconnected(NetworkManager.DisconnectType reason, string message)
+        {
+            WearablesRequestEvent.Set();
+            WearablesDownloadedEvent.Set();
+            CachedResponseEvent.Set();
+            UpdateEvent.Set();
+        }
+
+        #endregion Callbacks
+    }
+}
Index: AssetManager.cs
===================================================================
--- AssetManager.cs	(revision 2399)
+++ AssetManager.cs	(working copy)
@@ -1,1518 +1,1520 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-using System.Threading;
-using System.IO;
-using OpenMetaverse;
-using OpenMetaverse.Packets;
-
-namespace OpenMetaverse
-{
-    #region Enums
-
-    /// <summary>
-    /// The different types of grid assets
-    /// </summary>
-    public enum AssetType : sbyte
-    {
-        /// <summary>Unknown asset type</summary>
-        Unknown = -1,
-        /// <summary>Texture asset, stores in JPEG2000 J2C stream format</summary>
-        Texture = 0,
-        /// <summary>Sound asset</summary>
-        Sound = 1,
-        /// <summary>Calling card for another avatar</summary>
-        CallingCard = 2,
-        /// <summary>Link to a location in world</summary>
-        Landmark = 3,
-        // <summary>Legacy script asset, you should never see one of these</summary>
-        //[Obsolete]
-        //Script = 4,
-        /// <summary>Collection of textures and parameters that can be 
-        /// worn by an avatar</summary>
-        Clothing = 5,
-        /// <summary>Primitive that can contain textures, sounds, 
-        /// scripts and more</summary>
-        Object = 6,
-        /// <summary>Notecard asset</summary>
-        Notecard = 7,
-        /// <summary>Holds a collection of inventory items</summary>
-        Folder = 8,
-        /// <summary>Root inventory folder</summary>
-        RootFolder = 9,
-        /// <summary>Linden scripting language script</summary>
-        LSLText = 10,
-        /// <summary>LSO bytecode for a script</summary>
-        LSLBytecode = 11,
-        /// <summary>Uncompressed TGA texture</summary>
-        TextureTGA = 12,
-        /// <summary>Collection of textures and shape parameters that can
-        /// be worn</summary>
-        Bodypart = 13,
-        /// <summary>Trash folder</summary>
-        TrashFolder = 14,
-        /// <summary>Snapshot folder</summary>
-        SnapshotFolder = 15,
-        /// <summary>Lost and found folder</summary>
-        LostAndFoundFolder = 16,
-        /// <summary>Uncompressed sound</summary>
-        SoundWAV = 17,
-        /// <summary>Uncompressed TGA non-square image, not to be used as a
-        /// texture</summary>
-        ImageTGA = 18,
-        /// <summary>Compressed JPEG non-square image, not to be used as a
-        /// texture</summary>
-        ImageJPEG = 19,
-        /// <summary>Animation</summary>
-        Animation = 20,
-        /// <summary>Sequence of animations, sounds, chat, and pauses</summary>
-        Gesture = 21,
-        /// <summary>Simstate file</summary>
-        Simstate = 22,
-    }
-
-    public enum EstateAssetType : int
-    {
-        None = -1,
-        Covenant = 0
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public enum StatusCode
-    {
-        /// <summary>OK</summary>
-        OK = 0,
-        /// <summary>Transfer completed</summary>
-        Done = 1,
-        /// <summary></summary>
-        Skip = 2,
-        /// <summary></summary>
-        Abort = 3,
-        /// <summary>Unknown error occurred</summary>
-        Error = -1,
-        /// <summary>Equivalent to a 404 error</summary>
-        UnknownSource = -2,
-        /// <summary>Client does not have permission for that resource</summary>
-        InsufficientPermissiosn = -3,
-        /// <summary>Unknown status</summary>
-        Unknown = -4
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public enum ChannelType : int
-    {
-        /// <summary></summary>
-        Unknown = 0,
-        /// <summary>Unknown</summary>
-        Misc = 1,
-        /// <summary>Virtually all asset transfers use this channel</summary>
-        Asset = 2
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public enum SourceType : int
-    {
-        /// <summary></summary>
-        Unknown = 0,
-        /// <summary>Asset from the asset server</summary>
-        Asset = 2,
-        /// <summary>Inventory item</summary>
-        SimInventoryItem = 3,
-        /// <summary>Estate asset, such as an estate covenant</summary>
-        SimEstate = 4
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public enum TargetType : int
-    {
-        /// <summary></summary>
-        Unknown = 0,
-        /// <summary></summary>
-        File = 1,
-        /// <summary></summary>
-        VFile = 2
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public enum ImageType : byte
-    {
-        /// <summary></summary>
-        Normal = 0,
-        /// <summary></summary>
-        Baked = 1
-    }
-
-    /// <summary>
-    /// Image file format
-    /// </summary>
-    public enum ImageCodec : byte
-    {
-        Invalid = 0,
-        RGB = 1,
-        J2C = 2,
-        BMP = 3,
-        TGA = 4,
-        JPEG = 5,
-        DXT = 6,
-        PNG = 7
-    }
-
-    public enum TransferError : int
-    {
-        None = 0,
-        Failed = -1,
-        AssetNotFound = -3,
-        AssetNotFoundInDatabase = -4,
-        InsufficientPermissions = -5,
-        EOF = -39,
-        CannotOpenFile = -42,
-        FileNotFound = -43,
-        FileIsEmpty = -44,
-        TCPTimeout = -23016,
-        CircuitGone = -23017
-    }
-
-    #endregion Enums
-
-    #region Transfer Classes
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public class Transfer
-    {
-        public UUID ID;
-        public int Size;
-        public byte[] AssetData = new byte[0];
-        public int Transferred;
-        public bool Success;
-        public AssetType AssetType;
-
-        private int transferStart;
-
-        /// <summary>Number of milliseconds passed since the last transfer
-        /// packet was received</summary>
-        public int TimeSinceLastPacket
-        {
-            get { return Environment.TickCount - transferStart; }
-            internal set { transferStart = Environment.TickCount + value; }
-        }
-
-        public Transfer()
-        {
-            AssetData = new byte[0];
-            transferStart = Environment.TickCount;
-        }
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public class AssetDownload : Transfer
-    {
-        public UUID AssetID;
-        public ChannelType Channel;
-        public SourceType Source;
-        public TargetType Target;
-        public StatusCode Status;
-        public float Priority;
-        public Simulator Simulator;
-
-        internal AutoResetEvent HeaderReceivedEvent = new AutoResetEvent(false);
-
-        public AssetDownload()
-            : base()
-        {
-        }
-    }
-
-    public class XferDownload : Transfer
-    {
-        public ulong XferID;
-        public UUID VFileID;
-        public AssetType Type;
-        public uint PacketNum;
-        public string Filename = String.Empty;
-
-        public XferDownload()
-            : base()
-        {
-        }
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public class ImageDownload : Transfer
-    {
-        public ushort PacketCount;
-        public ImageCodec Codec;
-        public bool NotFound;
-        public Simulator Simulator;
-        public SortedList<ushort, ushort> PacketsSeen;
-        public ImageType ImageType;
-        public int DiscardLevel;
-        public float Priority;
-
-        internal int InitialDataSize;
-        internal AutoResetEvent HeaderReceivedEvent = new AutoResetEvent(false);
-
-        public ImageDownload()
-            : base()
-        {
-        }
-    }
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public class AssetUpload : Transfer
-    {
-        public UUID AssetID;
-        public AssetType Type;
-        public ulong XferID;
-        public uint PacketNum;
-
-        public AssetUpload()
-            : base()
-        {
-        }
-    }
-
-    public class ImageRequest
-    {
-        public ImageRequest(UUID imageid, ImageType type, float priority, int discardLevel)
-        {
-            ImageID = imageid;
-            Type = type;
-            Priority = priority;
-            DiscardLevel = discardLevel;
-        }
-        public UUID ImageID;
-        public ImageType Type;
-        public float Priority;
-        public int DiscardLevel;
-    }
-    #endregion Transfer Classes
-
-    /// <summary>
-    /// 
-    /// </summary>
-    public class AssetManager
-    {
-        #region Delegates
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="transfer"></param>
-        /// <param name="asset"></param>
-        public delegate void AssetReceivedCallback(AssetDownload transfer, Asset asset);
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="xfer"></param>
-        public delegate void XferReceivedCallback(XferDownload xfer);
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="image"></param>
-        /// <param name="asset"></param>
-        public delegate void ImageReceivedCallback(ImageDownload image, AssetTexture asset);
-        /// <summary>
-        /// 
-        /// </summary>
-        public delegate void ImageReceiveProgressCallback(UUID image, int lastPacket, int recieved, int total);
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="upload"></param>
-        public delegate void AssetUploadedCallback(AssetUpload upload);
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="upload"></param>
-        public delegate void UploadProgressCallback(AssetUpload upload);
-
-        #endregion Delegates
-
-        #region Events
-
-        /// <summary></summary>
-        public event AssetReceivedCallback OnAssetReceived;
-        /// <summary></summary>
-        public event XferReceivedCallback OnXferReceived;
-        /// <summary></summary>
-        public event ImageReceivedCallback OnImageReceived;
-        /// <summary></summary>
-        public event ImageReceiveProgressCallback OnImageReceiveProgress;
-        /// <summary></summary>
-        public event AssetUploadedCallback OnAssetUploaded;
-        /// <summary></summary>
-        public event UploadProgressCallback OnUploadProgress;
-
-        #endregion Events
-
-        /// <summary>Texture download cache</summary>
-        public TextureCache Cache;
-
-        private GridClient Client;
-        private Dictionary<UUID, Transfer> Transfers = new Dictionary<UUID, Transfer>();
-        private AssetUpload PendingUpload;
-        private object PendingUploadLock = new object();
-        private volatile bool WaitingForUploadConfirm = false;
-        private System.Timers.Timer RefreshDownloadsTimer = new System.Timers.Timer(500.0);
-        
-        /// <summary>
-        /// Default constructor
-        /// </summary>
-        /// <param name="client">A reference to the GridClient object</param>
-        public AssetManager(GridClient client)
-        {
-            Client = client;
-            Cache = new TextureCache(client);
-
-            // Transfer packets for downloading large assets
-            Client.Network.RegisterCallback(PacketType.TransferInfo, new NetworkManager.PacketCallback(TransferInfoHandler));
-            Client.Network.RegisterCallback(PacketType.TransferPacket, new NetworkManager.PacketCallback(TransferPacketHandler));
-
-            // Image downloading packets
-            Client.Network.RegisterCallback(PacketType.ImageData, new NetworkManager.PacketCallback(ImageDataHandler));
-            Client.Network.RegisterCallback(PacketType.ImagePacket, new NetworkManager.PacketCallback(ImagePacketHandler));
-            Client.Network.RegisterCallback(PacketType.ImageNotInDatabase, new NetworkManager.PacketCallback(ImageNotInDatabaseHandler));
-
-            // Xfer packets for uploading large assets
-            Client.Network.RegisterCallback(PacketType.RequestXfer, new NetworkManager.PacketCallback(RequestXferHandler));
-            Client.Network.RegisterCallback(PacketType.ConfirmXferPacket, new NetworkManager.PacketCallback(ConfirmXferPacketHandler));
-            Client.Network.RegisterCallback(PacketType.AssetUploadComplete, new NetworkManager.PacketCallback(AssetUploadCompleteHandler));
-
-            // Xfer packet for downloading misc assets
-            Client.Network.RegisterCallback(PacketType.SendXferPacket, new NetworkManager.PacketCallback(SendXferPacketHandler));
-
-            // HACK: Re-request stale pending image downloads
-            RefreshDownloadsTimer.Elapsed += new System.Timers.ElapsedEventHandler(RefreshDownloadsTimer_Elapsed);
-            RefreshDownloadsTimer.Start();
-        }
-
-        private void RefreshDownloadsTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
-        {
-            lock (Transfers)
-            {
-                foreach (Transfer transfer in Transfers.Values)
-                {
-                    if (transfer is ImageDownload)
-                    {
-                        ImageDownload download = (ImageDownload)transfer;
-
-                        uint packet = 0;
-                        
-                        if (download.PacketsSeen != null && download.PacketsSeen.Count > 0)
-                        {
-                            lock (download.PacketsSeen)
-                            {
-                                bool first = true;
-                                foreach (KeyValuePair<ushort, ushort> packetSeen in download.PacketsSeen)
-                                {
-                                    if (first)
-                                    {
-                                        // Initially set this to the earliest packet received in the transfer
-                                        packet = packetSeen.Value;
-                                        first = false;
-                                    }
-                                    else
-                                    {
-                                        ++packet;
-
-                                        // If there is a missing packet in the list, break and request the download
-                                        // resume here
-                                        if (packetSeen.Value != packet)
-                                        {
-                                            --packet;
-                                            break;
-                                        }
-                                    }
-                                }
-
-                                ++packet;
-                            }
-                        }
-
-                        if (download.TimeSinceLastPacket > 5000)
-                        {
-                            --download.DiscardLevel;
-                            download.TimeSinceLastPacket = 0;
-                            RequestImage(download.ID, download.ImageType, download.Priority, download.DiscardLevel, packet);
-                        }
-                    }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Request an asset download
-        /// </summary>
-        /// <param name="assetID">Asset UUID</param>
-        /// <param name="type">Asset type, must be correct for the transfer to succeed</param>
-        /// <param name="priority">Whether to give this transfer an elevated priority</param>
-        /// <returns>The transaction ID generated for this transfer</returns>
-        public UUID RequestAsset(UUID assetID, AssetType type, bool priority)
-        {
-            AssetDownload transfer = new AssetDownload();
-            transfer.ID = UUID.Random();
-            transfer.AssetID = assetID;
-            //transfer.AssetType = type; // Set in TransferInfoHandler.
-            transfer.Priority = 100.0f + (priority ? 1.0f : 0.0f);
-            transfer.Channel = ChannelType.Asset;
-            transfer.Source = SourceType.Asset;
-            transfer.Simulator = Client.Network.CurrentSim;
-
-            // Add this transfer to the dictionary
-            lock (Transfers) Transfers[transfer.ID] = transfer;
-
-            // Build the request packet and send it
-            TransferRequestPacket request = new TransferRequestPacket();
-            request.TransferInfo.ChannelType = (int)transfer.Channel;
-            request.TransferInfo.Priority = transfer.Priority;
-            request.TransferInfo.SourceType = (int)transfer.Source;
-            request.TransferInfo.TransferID = transfer.ID;
-
-            byte[] paramField = new byte[20];
-            Buffer.BlockCopy(assetID.GetBytes(), 0, paramField, 0, 16);
-            Buffer.BlockCopy(Utils.IntToBytes((int)type), 0, paramField, 16, 4);
-            request.TransferInfo.Params = paramField;
-
-            Client.Network.SendPacket(request, transfer.Simulator);
-            return transfer.ID;
-        }
-
-        /// <summary>
-        /// Request an asset download through the almost deprecated Xfer system
-        /// </summary>
-        /// <param name="filename">Filename of the asset to request</param>
-        /// <param name="deleteOnCompletion">Whether or not to delete the asset
-        /// off the server after it is retrieved</param>
-        /// <param name="useBigPackets">Use large transfer packets or not</param>
-        /// <param name="vFileID">UUID of the file to request, if filename is
-        /// left empty</param>
-        /// <param name="vFileType">Asset type of <code>vFileID</code>, or
-        /// <code>AssetType.Unknown</code> if filename is not empty</param>
-        /// <param name="fromCache">Sets the FilePath in the request to Cache
-        /// (4) if true, otherwise Unknown (0) is used</param>
-        /// <returns></returns>
-        public ulong RequestAssetXfer(string filename, bool deleteOnCompletion, bool useBigPackets, UUID vFileID, AssetType vFileType,
-            bool fromCache)
-        {
-            UUID uuid = UUID.Random();
-            ulong id = uuid.GetULong();
-
-            XferDownload transfer = new XferDownload();
-            transfer.XferID = id;
-            transfer.ID = new UUID(id); // Our dictionary tracks transfers with UUIDs, so convert the ulong back
-            transfer.Filename = filename;
-            transfer.VFileID = vFileID;
-            transfer.AssetType = vFileType;
-
-            // Add this transfer to the dictionary
-            lock (Transfers) Transfers[transfer.ID] = transfer;
-
-            RequestXferPacket request = new RequestXferPacket();
-            request.XferID.ID = id;
-            request.XferID.Filename = Utils.StringToBytes(filename);
-            request.XferID.FilePath = fromCache ? (byte)4 : (byte)0;
-            request.XferID.DeleteOnCompletion = deleteOnCompletion;
-            request.XferID.UseBigPackets = useBigPackets;
-            request.XferID.VFileID = vFileID;
-            request.XferID.VFileType = (short)vFileType;
-
-            Client.Network.SendPacket(request);
-
-            return id;
-        }
-
-        /// <summary>
-        /// 
-        /// </summary>
-        /// <param name="assetID">Use UUID.Zero if you do not have the 
-        /// asset ID but have all the necessary permissions</param>
-        /// <param name="itemID">The item ID of this asset in the inventory</param>
-        /// <param name="taskID">Use UUID.Zero if you are not requesting an 
-        /// asset from an object inventory</param>
-        /// <param name="ownerID">The owner of this asset</param>
-        /// <param name="type">Asset type</param>
-        /// <param name="priority">Whether to prioritize this asset download or not</param>
-        public UUID RequestInventoryAsset(UUID assetID, UUID itemID, UUID taskID, UUID ownerID, AssetType type, bool priority)
-        {
-            AssetDownload transfer = new AssetDownload();
-            transfer.ID = UUID.Random();
-            transfer.AssetID = assetID;
-            //transfer.AssetType = type; // Set in TransferInfoHandler.
-            transfer.Priority = 100.0f + (priority ? 1.0f : 0.0f);
-            transfer.Channel = ChannelType.Asset;
-            transfer.Source = SourceType.SimInventoryItem;
-            transfer.Simulator = Client.Network.CurrentSim;
-
-            // Add this transfer to the dictionary
-            lock (Transfers) Transfers[transfer.ID] = transfer;
-
-            // Build the request packet and send it
-            TransferRequestPacket request = new TransferRequestPacket();
-            request.TransferInfo.ChannelType = (int)transfer.Channel;
-            request.TransferInfo.Priority = transfer.Priority;
-            request.TransferInfo.SourceType = (int)transfer.Source;
-            request.TransferInfo.TransferID = transfer.ID;
-
-            byte[] paramField = new byte[100];
-            Buffer.BlockCopy(Client.Self.AgentID.GetBytes(), 0, paramField, 0, 16);
-            Buffer.BlockCopy(Client.Self.SessionID.GetBytes(), 0, paramField, 16, 16);
-            Buffer.BlockCopy(ownerID.GetBytes(), 0, paramField, 32, 16);
-            Buffer.BlockCopy(taskID.GetBytes(), 0, paramField, 48, 16);
-            Buffer.BlockCopy(itemID.GetBytes(), 0, paramField, 64, 16);
-            Buffer.BlockCopy(assetID.GetBytes(), 0, paramField, 80, 16);
-            Buffer.BlockCopy(Utils.IntToBytes((int)type), 0, paramField, 96, 4);
-            request.TransferInfo.Params = paramField;
-
-            Client.Network.SendPacket(request, transfer.Simulator);
-            return transfer.ID;
-        }
-
-        public UUID RequestInventoryAsset(InventoryItem item, bool priority)
-        {
-            return RequestInventoryAsset(item.AssetUUID, item.UUID, UUID.Zero, item.OwnerID, item.AssetType, priority);
-        }
-
-        public void RequestEstateAsset()
-        {
-            throw new Exception("This function is not implemented yet!");
-        }
-
-        /// <summary>
-        /// Initiate an image download. This is an asynchronous function
-        /// </summary>
-        /// <param name="imageID">The image to download</param>
-        /// <param name="type">Type of the image to download, either a baked
-        /// avatar texture or a normal texture</param>
-        public void RequestImage(UUID imageID, ImageType type)
-        {
-            RequestImage(imageID, type, 1013000.0f, 0, 0);
-        }
-
-        /// <summary>
-        /// Initiate an image download. This is an asynchronous function
-        /// </summary>
-        /// <param name="imageID">The image to download</param>
-        /// <param name="type">Type of the image to download, either a baked
-        /// avatar texture or a normal texture</param>
-        /// <param name="priority">Priority level of the download. Default is
-        /// <c>1,013,000.0f</c></param>
-        /// <param name="discardLevel">Number of quality layers to discard.
-        /// This controls the end marker of the data sent</param>
-        /// <param name="packetNum">Packet number to start the download at.
-        /// This controls the start marker of the data sent</param>
-        /// <remarks>Sending a priority of 0 and a discardlevel of -1 aborts
-        /// download</remarks>
-        public void RequestImage(UUID imageID, ImageType type, float priority, int discardLevel, uint packetNum)
-        {
-            if (Cache.HasImage(imageID))
-            {
-                ImageDownload transfer = Cache.GetCachedImage(imageID);
-                transfer.ImageType = type;
-
-                if (null != transfer)
-                {
-                    if (null != OnImageReceived)
-                    {
-                        AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
-
-                        try { OnImageReceived(transfer, asset); }
-                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                    }
-                    return;
-                }
-            }
-
-            // Priority == 0 && DiscardLevel == -1 means cancel the transfer
-            if (priority.Equals(0) && discardLevel.Equals(-1))
-            {
-                if (Transfers.ContainsKey(imageID))
-                    Transfers.Remove(imageID);
-
-                RequestImagePacket cancel = new RequestImagePacket();
-                cancel.AgentData.AgentID = Client.Self.AgentID;
-                cancel.AgentData.SessionID = Client.Self.SessionID;
-                cancel.RequestImage = new RequestImagePacket.RequestImageBlock[1];
-                cancel.RequestImage[0] = new RequestImagePacket.RequestImageBlock();
-                cancel.RequestImage[0].DiscardLevel = -1;
-                cancel.RequestImage[0].DownloadPriority = 0;
-                cancel.RequestImage[0].Packet = 0;
-                cancel.RequestImage[0].Image = imageID;
-                cancel.RequestImage[0].Type = 0;
-            }
-            else
-            {
-                Simulator currentSim = Client.Network.CurrentSim;
-
-                if (!Transfers.ContainsKey(imageID))
-                {
-                    // New download
-                    ImageDownload transfer = new ImageDownload();
-                    transfer.ID = imageID;
-                    transfer.Simulator = currentSim;
-                    transfer.ImageType = type;
-                    transfer.DiscardLevel = discardLevel;
-                    transfer.Priority = priority;
-
-                    // Add this transfer to the dictionary
-                    lock (Transfers) Transfers[transfer.ID] = transfer;
-
-                    Logger.DebugLog("Adding image " + imageID.ToString() + " to the download queue");
-                }
-                else
-                {
-                    // Already downloading, just updating the priority
-                    Transfer transfer = Transfers[imageID];
-                    float percentComplete = ((float)transfer.Transferred / (float)transfer.Size) * 100f;
-                    if (Single.IsNaN(percentComplete))
-                        percentComplete = 0f;
-
-                    Logger.DebugLog(String.Format("Updating priority on image transfer {0}, {1}% complete",
-                        imageID, Math.Round(percentComplete, 2)));
-                }
-
-                // Build and send the request packet
-                RequestImagePacket request = new RequestImagePacket();
-                request.AgentData.AgentID = Client.Self.AgentID;
-                request.AgentData.SessionID = Client.Self.SessionID;
-                request.RequestImage = new RequestImagePacket.RequestImageBlock[1];
-                request.RequestImage[0] = new RequestImagePacket.RequestImageBlock();
-                request.RequestImage[0].DiscardLevel = (sbyte)discardLevel;
-                request.RequestImage[0].DownloadPriority = priority;
-                request.RequestImage[0].Packet = packetNum;
-                request.RequestImage[0].Image = imageID;
-                request.RequestImage[0].Type = (byte)type;
-
-                Client.Network.SendPacket(request, currentSim);
-            }
-        }
-
-        /// <summary>
-        /// Requests multiple Images
-        /// </summary>
-        /// <param name="Images">List of requested images</param>
-        public void RequestImages(List<ImageRequest> Images)
-        {
-            for (int iri = 0; iri < Images.Count; iri++)
-            {
-                if (Transfers.ContainsKey(Images[iri].ImageID))
-                {
-                    Images.RemoveAt(iri);
-                }
-
-                if (Cache.HasImage(Images[iri].ImageID))
-                {
-                    ImageDownload transfer = Cache.GetCachedImage(Images[iri].ImageID);
-                    if (null != transfer)
-                    {
-                        if (null != OnImageReceived)
-                        {
-                            AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
-
-                            try { OnImageReceived(transfer, asset); }
-                            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                        }
-
-                        Images.RemoveAt(iri);
-                    }
-                }
-            }
-
-            if (Images.Count > 0)
-            {
-                // Build and send the request packet
-                RequestImagePacket request = new RequestImagePacket();
-                request.AgentData.AgentID = Client.Self.AgentID;
-                request.AgentData.SessionID = Client.Self.SessionID;
-                request.RequestImage = new RequestImagePacket.RequestImageBlock[Images.Count];
-
-                for (int iru = 0; iru < Images.Count; ++iru)
-                {
-                    ImageDownload transfer = new ImageDownload();
-                    //transfer.AssetType = AssetType.Texture // Handled in ImageDataHandler.
-                    transfer.ID = Images[iru].ImageID;
-                    transfer.Simulator = Client.Network.CurrentSim;
-                    transfer.ImageType = Images[iru].Type;
-                    transfer.DiscardLevel = Images[iru].DiscardLevel;
-                    transfer.Priority = Images[iru].Priority;
-
-                    // Add this transfer to the dictionary
-                    lock (Transfers) Transfers[transfer.ID] = transfer;
-                    request.RequestImage[iru] = new RequestImagePacket.RequestImageBlock();
-                    request.RequestImage[iru].DiscardLevel = (sbyte)Images[iru].DiscardLevel;
-                    request.RequestImage[iru].DownloadPriority = Images[iru].Priority;
-                    request.RequestImage[iru].Packet = 0;
-                    request.RequestImage[iru].Image = Images[iru].ImageID;
-                    request.RequestImage[iru].Type = (byte)Images[iru].Type;
-                }
-
-                Client.Network.SendPacket(request, Client.Network.CurrentSim);
-            }
-            else
-            {
-                Logger.Log("RequestImages() called for an image(s) we are already downloading or an empty list, ignoring",
-                    Helpers.LogLevel.Info, Client);
-            }
-        }
-
-        public UUID RequestUpload(Asset asset, bool storeLocal)
-        {
-            if (asset.AssetData == null)
-                throw new ArgumentException("Can't upload an asset with no data (did you forget to call Encode?)");
-
-            UUID assetID;
-            UUID transferID = RequestUpload(out assetID, asset.AssetType, asset.AssetData, storeLocal);
-            asset.AssetID = assetID;
-            return transferID;
-        }
-        
-        public UUID RequestUpload(AssetType type, byte[] data, bool storeLocal)
-        {
-            UUID assetID;
-            return RequestUpload(out assetID, type, data, storeLocal);
-        }
-
-        /// <summary>
-        /// Initiate an asset upload
-        /// </summary>
-        /// <param name="assetID">The ID this asset will have if the
-        /// upload succeeds</param>
-        /// <param name="type">Asset type to upload this data as</param>
-        /// <param name="data">Raw asset data to upload</param>
-        /// <param name="storeLocal">Whether to store this asset on the local
-        /// simulator or the grid-wide asset server</param>
-        /// <returns>The transaction ID of this transfer</returns>
-        public UUID RequestUpload(out UUID assetID, AssetType type, byte[] data, bool storeLocal)
-        {
-            AssetUpload upload = new AssetUpload();
-            upload.AssetData = data;
-            upload.AssetType = type;
-            upload.ID = UUID.Random();
-            assetID = UUID.Combine(upload.ID, Client.Self.SecureSessionID);
-            upload.AssetID = assetID;
-            upload.Size = data.Length;
-            upload.XferID = 0;
-
-            // Build and send the upload packet
-            AssetUploadRequestPacket request = new AssetUploadRequestPacket();
-            request.AssetBlock.StoreLocal = storeLocal;
-            request.AssetBlock.Tempfile = false; // This field is deprecated
-            request.AssetBlock.TransactionID = upload.ID;
-            request.AssetBlock.Type = (sbyte)type;
-
-            if (data.Length + 100 < Settings.MAX_PACKET_SIZE)
-            {
-                Logger.Log(
-                    String.Format("Beginning asset upload [Single Packet], ID: {0}, AssetID: {1}, Size: {2}",
-                    upload.ID.ToString(), upload.AssetID.ToString(), upload.Size), Helpers.LogLevel.Info, Client);
-
-                // The whole asset will fit in this packet, makes things easy
-                request.AssetBlock.AssetData = data;
-                upload.Transferred = data.Length;
-            }
-            else
-            {
-                Logger.Log(
-                    String.Format("Beginning asset upload [Multiple Packets], ID: {0}, AssetID: {1}, Size: {2}",
-                    upload.ID.ToString(), upload.AssetID.ToString(), upload.Size), Helpers.LogLevel.Info, Client);
-
-                // Asset is too big, send in multiple packets
-                request.AssetBlock.AssetData = new byte[0];
-            }
-
-            // Wait for the previous upload to receive a RequestXferPacket
-            lock (PendingUploadLock)
-            {
-                const int UPLOAD_CONFIRM_TIMEOUT = 10000;
-                const int SLEEP_INTERVAL = 50;
-                int t = 0;
-                while (WaitingForUploadConfirm && t < UPLOAD_CONFIRM_TIMEOUT)
-                {
-                    System.Threading.Thread.Sleep(SLEEP_INTERVAL);
-                    t += SLEEP_INTERVAL;
-                }
-
-                if (t < UPLOAD_CONFIRM_TIMEOUT)
-                {
-                    WaitingForUploadConfirm = true;
-                    PendingUpload = upload;
-                    Client.Network.SendPacket(request);
-
-                    return upload.ID;
-                }
-                else
-                {
-                    throw new Exception("Timeout waiting for previous asset upload to begin");
-                }
-            }
-        }
-
-        #region Helpers
-
-        private Asset CreateAssetWrapper(AssetType type)
-        {
-            Asset asset;
-
-            switch (type)
-            {
-                case AssetType.Notecard:
-                    asset = new AssetNotecard();
-                    break;
-                case AssetType.LSLText:
-                    asset = new AssetScriptText();
-                    break;
-                case AssetType.LSLBytecode:
-                    asset = new AssetScriptBinary();
-                    break;
-                case AssetType.Texture:
-                    asset = new AssetTexture();
-                    break;
-                case AssetType.Object:
-                    asset = new AssetPrim();
-                    break;
-                case AssetType.Clothing:
-                    asset = new AssetClothing();
-                    break;
-                case AssetType.Bodypart:
-                    asset = new AssetBodypart();
-                    break;
-                case AssetType.Animation:
-                    asset = new AssetAnimation();
-                    break;
-                case AssetType.Sound:
-                    asset = new AssetSound();
-                    break;
-                default:
-                    Logger.Log("Unimplemented asset type: " + type, Helpers.LogLevel.Error, Client);
-                    return null;
-            }
-
-            return asset;
-        }
-
-        private Asset WrapAsset(AssetDownload download)
-        {
-            Asset asset = CreateAssetWrapper(download.AssetType);
-            if (asset != null)
-            {
-                asset.AssetID = download.AssetID;
-                asset.AssetData = download.AssetData;
-                return asset;
-            }
-            else
-            {
-                return null;
-            }
-        }
-
-        private void SendNextUploadPacket(AssetUpload upload)
-        {
-            SendXferPacketPacket send = new SendXferPacketPacket();
-
-            send.XferID.ID = upload.XferID;
-            send.XferID.Packet = upload.PacketNum++;
-
-            if (send.XferID.Packet == 0)
-            {
-                // The first packet reserves the first four bytes of the data for the
-                // total length of the asset and appends 1000 bytes of data after that
-                send.DataPacket.Data = new byte[1004];
-                Buffer.BlockCopy(Utils.IntToBytes(upload.Size), 0, send.DataPacket.Data, 0, 4);
-                Buffer.BlockCopy(upload.AssetData, 0, send.DataPacket.Data, 4, 1000);
-                upload.Transferred += 1000;
-
-                lock (Transfers)
-                {
-                    Transfers.Remove(upload.AssetID);
-                    Transfers[upload.ID] = upload;
-                }
-            }
-            else if ((send.XferID.Packet + 1) * 1000 < upload.Size)
-            {
-                // This packet is somewhere in the middle of the transfer, or a perfectly
-                // aligned packet at the end of the transfer
-                send.DataPacket.Data = new byte[1000];
-                Buffer.BlockCopy(upload.AssetData, upload.Transferred, send.DataPacket.Data, 0, 1000);
-                upload.Transferred += 1000;
-            }
-            else
-            {
-                // Special handler for the last packet which will be less than 1000 bytes
-                int lastlen = upload.Size - ((int)send.XferID.Packet * 1000);
-                send.DataPacket.Data = new byte[lastlen];
-                Buffer.BlockCopy(upload.AssetData, (int)send.XferID.Packet * 1000, send.DataPacket.Data, 0, lastlen);
-                send.XferID.Packet |= (uint)0x80000000; // This signals the final packet
-                upload.Transferred += lastlen;
-            }
-
-            Client.Network.SendPacket(send);
-        }
-
-        private void SendConfirmXferPacket(ulong xferID, uint packetNum)
-        {
-            ConfirmXferPacketPacket confirm = new ConfirmXferPacketPacket();
-            confirm.XferID.ID = xferID;
-            confirm.XferID.Packet = packetNum;
-
-            Client.Network.SendPacket(confirm);
-        }
-
-        #endregion Helpers
-
-        #region Transfer Callbacks
-
-        private void TransferInfoHandler(Packet packet, Simulator simulator)
-        {
-            if (OnAssetReceived != null)
-            {
-                TransferInfoPacket info = (TransferInfoPacket)packet;
-                Transfer transfer;
-                AssetDownload download;
-
-                if (Transfers.TryGetValue(info.TransferInfo.TransferID, out transfer))
-                {
-                    download = (AssetDownload)transfer;
-
-                    download.Channel = (ChannelType)info.TransferInfo.ChannelType;
-                    download.Status = (StatusCode)info.TransferInfo.Status;
-                    download.Target = (TargetType)info.TransferInfo.TargetType;
-                    download.Size = info.TransferInfo.Size;
-
-                    // TODO: Once we support mid-transfer status checking and aborting this
-                    // will need to become smarter
-                    if (download.Status != StatusCode.OK)
-                    {
-                        Logger.Log("Transfer failed with status code " + download.Status, Helpers.LogLevel.Warning, Client);
-
-                        lock (Transfers) Transfers.Remove(download.ID);
-
-                        // No data could have been received before the TransferInfo packet
-                        download.AssetData = null;
-
-                        // Fire the event with our transfer that contains Success = false;
-                        try { OnAssetReceived(download, null); }
-                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                    }
-                    else
-                    {
-                        download.AssetData = new byte[download.Size];
-
-                        if (download.Source == SourceType.Asset && info.TransferInfo.Params.Length == 20)
-                        {
-                            download.AssetID = new UUID(info.TransferInfo.Params, 0);
-                            download.AssetType = (AssetType)(sbyte)info.TransferInfo.Params[16];
-
-                            //Client.DebugLog(String.Format("TransferInfo packet received. AssetID: {0} Type: {1}",
-                            //    transfer.AssetID, type));
-                        }
-                        else if (download.Source == SourceType.SimInventoryItem && info.TransferInfo.Params.Length == 100)
-                        {
-                            // TODO: Can we use these?
-                            //UUID agentID = new UUID(info.TransferInfo.Params, 0);
-                            //UUID sessionID = new UUID(info.TransferInfo.Params, 16);
-                            //UUID ownerID = new UUID(info.TransferInfo.Params, 32);
-                            //UUID taskID = new UUID(info.TransferInfo.Params, 48);
-                            //UUID itemID = new UUID(info.TransferInfo.Params, 64);
-                            download.AssetID = new UUID(info.TransferInfo.Params, 80);
-                            download.AssetType = (AssetType)(sbyte)info.TransferInfo.Params[96];
-
-                            //Client.DebugLog(String.Format("TransferInfo packet received. AgentID: {0} SessionID: {1} " + 
-                            //    "OwnerID: {2} TaskID: {3} ItemID: {4} AssetID: {5} Type: {6}", agentID, sessionID, 
-                            //    ownerID, taskID, itemID, transfer.AssetID, type));
-                        }
-                        else
-                        {
-                            Logger.Log("Received a TransferInfo packet with a SourceType of " + download.Source.ToString() +
-                                " and a Params field length of " + info.TransferInfo.Params.Length,
-                                Helpers.LogLevel.Warning, Client);
-                        }
-                    }
-                }
-                else
-                {
-                    Logger.Log("Received a TransferInfo packet for an asset we didn't request, TransferID: " +
-                        info.TransferInfo.TransferID, Helpers.LogLevel.Warning, Client);
-                }
-            }
-        }
-
-        private void TransferPacketHandler(Packet packet, Simulator simulator)
-        {
-            TransferPacketPacket asset = (TransferPacketPacket)packet;
-            Transfer transfer;
-            AssetDownload download;
-
-            if (Transfers.TryGetValue(asset.TransferData.TransferID, out transfer))
-            {
-                download = (AssetDownload)transfer;
-
-                if (download.Size == 0)
-                {
-                    Logger.DebugLog("TransferPacket received ahead of the transfer header, blocking...", Client);
-
-                    // We haven't received the header yet, block until it's received or times out
-                    download.HeaderReceivedEvent.WaitOne(1000 * 5, false);
-
-                    if (download.Size == 0)
-                    {
-                        Logger.Log("Timed out while waiting for the asset header to download for " +
-                            download.ID.ToString(), Helpers.LogLevel.Warning, Client);
-
-                        // Abort the transfer
-                        TransferAbortPacket abort = new TransferAbortPacket();
-                        abort.TransferInfo.ChannelType = (int)download.Channel;
-                        abort.TransferInfo.TransferID = download.ID;
-                        Client.Network.SendPacket(abort, download.Simulator);
-
-                        download.Success = false;
-                        lock (Transfers) Transfers.Remove(download.ID);
-
-                        // Fire the event with our transfer that contains Success = false
-                        if (OnAssetReceived != null)
-                        {
-                            try { OnAssetReceived(download, null); }
-                            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                        }
-
-                        return;
-                    }
-                }
-
-                // This assumes that every transfer packet except the last one is exactly 1000 bytes,
-                // hopefully that is a safe assumption to make
-                try
-                {
-                    Buffer.BlockCopy(asset.TransferData.Data, 0, download.AssetData, 1000 * asset.TransferData.Packet,
-                        asset.TransferData.Data.Length);
-                    download.Transferred += asset.TransferData.Data.Length;
-                }
-                catch (ArgumentException)
-                {
-                    Logger.Log(String.Format("TransferPacket handling failed. TransferData.Data.Length={0}, AssetData.Length={1}, TransferData.Packet={2}",
-                        asset.TransferData.Data.Length, download.AssetData.Length, asset.TransferData.Packet), Helpers.LogLevel.Error);
-                    return;
-                }
-
-                //Client.DebugLog(String.Format("Transfer packet {0}, received {1}/{2}/{3} bytes for asset {4}",
-                //    asset.TransferData.Packet, asset.TransferData.Data.Length, transfer.Transferred, transfer.Size,
-                //    transfer.AssetID.ToString()));
-
-                // Check if we downloaded the full asset
-                if (download.Transferred >= download.Size)
-                {
-                    Logger.DebugLog("Transfer for asset " + download.AssetID.ToString() + " completed", Client);
-
-                    download.Success = true;
-                    lock (Transfers) Transfers.Remove(download.ID);
-
-                    if (OnAssetReceived != null)
-                    {
-                        try { OnAssetReceived(download, WrapAsset(download)); }
-                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                    }
-                }
-            }
-        }
-
-        #endregion Transfer Callbacks
-
-        #region Xfer Callbacks
-
-        private void RequestXferHandler(Packet packet, Simulator simulator)
-        {
-            if (PendingUpload == null)
-                Logger.Log("Received a RequestXferPacket for an unknown asset upload", Helpers.LogLevel.Warning, Client);
-            else
-            {
-                AssetUpload upload = PendingUpload;
-                PendingUpload = null;
-                WaitingForUploadConfirm = false;
-                RequestXferPacket request = (RequestXferPacket)packet;
-
-                upload.XferID = request.XferID.ID;
-                upload.Type = (AssetType)request.XferID.VFileType;
-
-                UUID transferID = new UUID(upload.XferID);
-                Transfers[transferID] = upload;
-
-                // Send the first packet containing actual asset data
-                SendNextUploadPacket(upload);
-            }
-        }
-
-        private void ConfirmXferPacketHandler(Packet packet, Simulator simulator)
-        {
-            ConfirmXferPacketPacket confirm = (ConfirmXferPacketPacket)packet;
-
-            // Building a new UUID every time an ACK is received for an upload is a horrible
-            // thing, but this whole Xfer system is horrible
-            UUID transferID = new UUID(confirm.XferID.ID);
-            Transfer transfer;
-            AssetUpload upload = null;
-
-            if (Transfers.TryGetValue(transferID, out transfer))
-            {
-                upload = (AssetUpload)transfer;
-
-                //Client.DebugLog(String.Format("ACK for upload {0} of asset type {1} ({2}/{3})",
-                //    upload.AssetID.ToString(), upload.Type, upload.Transferred, upload.Size));
-
-                if (OnUploadProgress != null)
-                {
-                    try { OnUploadProgress(upload); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-
-                if (upload.Transferred < upload.Size)
-                    SendNextUploadPacket(upload);
-            }
-        }
-
-        private void AssetUploadCompleteHandler(Packet packet, Simulator simulator)
-        {
-            AssetUploadCompletePacket complete = (AssetUploadCompletePacket)packet;
-
-            // If we uploaded an asset in a single packet, RequestXferHandler()
-            // will never be called so we need to set this here as well
-            WaitingForUploadConfirm = false;
-
-            if (OnAssetUploaded != null)
-            {
-                bool found = false;
-                KeyValuePair<UUID, Transfer> foundTransfer = new KeyValuePair<UUID, Transfer>();
-
-                // Xfer system sucks really really bad. Where is the damn XferID?
-                lock (Transfers)
-                {
-                    foreach (KeyValuePair<UUID, Transfer> transfer in Transfers)
-                    {
-                        if (transfer.Value.GetType() == typeof(AssetUpload))
-                        {
-                            AssetUpload upload = (AssetUpload)transfer.Value;
-
-                            if ((upload).AssetID == complete.AssetBlock.UUID)
-                            {
-                                found = true;
-                                foundTransfer = transfer;
-                                upload.Success = complete.AssetBlock.Success;
-                                upload.Type = (AssetType)complete.AssetBlock.Type;
-                                break;
-                            }
-                        }
-                    }
-                }
-
-                if (found)
-                {
-                    lock (Transfers) Transfers.Remove(foundTransfer.Key);
-
-                    try { OnAssetUploaded((AssetUpload)foundTransfer.Value); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-                else
-                {
-                    Logger.Log(String.Format(
-                        "Got an AssetUploadComplete on an unrecognized asset, AssetID: {0}, Type: {1}, Success: {2}",
-                        complete.AssetBlock.UUID, (AssetType)complete.AssetBlock.Type, complete.AssetBlock.Success),
-                        Helpers.LogLevel.Warning);
-                }
-            }
-        }
-
-        private void SendXferPacketHandler(Packet packet, Simulator simulator)
-        {
-            SendXferPacketPacket xfer = (SendXferPacketPacket)packet;
-
-            // Lame ulong to UUID conversion, please go away Xfer system
-            UUID transferID = new UUID(xfer.XferID.ID);
-            Transfer transfer;
-            XferDownload download = null;
-
-            if (Transfers.TryGetValue(transferID, out transfer))
-            {
-                download = (XferDownload)transfer;
-
-                // Apply a mask to get rid of the "end of transfer" bit
-                uint packetNum = xfer.XferID.Packet & 0x0FFFFFFF;
-
-                // Check for out of order packets, possibly indicating a resend
-                if (packetNum != download.PacketNum)
-                {
-                    if (packetNum == download.PacketNum - 1)
-                    {
-                        Logger.DebugLog("Resending Xfer download confirmation for packet " + packetNum, Client);
-                        SendConfirmXferPacket(download.XferID, packetNum);
-                    }
-                    else
-                    {
-                        Logger.Log("Out of order Xfer packet in a download, got " + packetNum + " expecting " + download.PacketNum,
-                            Helpers.LogLevel.Warning, Client);
-                        // Re-confirm the last packet we actually received
-                        SendConfirmXferPacket(download.XferID, download.PacketNum - 1);
-                    }
-
-                    return;
-                }
-
-                if (packetNum == 0)
-                {
-                    // This is the first packet received in the download, the first four bytes are a size integer
-                    // in little endian ordering
-                    byte[] bytes = xfer.DataPacket.Data;
-                    download.Size = (bytes[0] + (bytes[1] << 8) + (bytes[2] << 16) + (bytes[3] << 24));
-                    download.AssetData = new byte[download.Size];
-
-                    Logger.DebugLog("Received first packet in an Xfer download of size " + download.Size);
-
-                    Buffer.BlockCopy(xfer.DataPacket.Data, 4, download.AssetData, 0, xfer.DataPacket.Data.Length - 4);
-                    download.Transferred += xfer.DataPacket.Data.Length - 4;
-                }
-                else
-                {
-                    Buffer.BlockCopy(xfer.DataPacket.Data, 0, download.AssetData, 1000 * (int)packetNum, xfer.DataPacket.Data.Length);
-                    download.Transferred += xfer.DataPacket.Data.Length;
-                }
-
-                // Increment the packet number to the packet we are expecting next
-                download.PacketNum++;
-
-                // Confirm receiving this packet
-                SendConfirmXferPacket(download.XferID, packetNum);
-
-                if ((xfer.XferID.Packet & 0x80000000) != 0)
-                {
-                    // This is the last packet in the transfer
-                    if (!String.IsNullOrEmpty(download.Filename))
-                        Logger.DebugLog("Xfer download for asset " + download.Filename + " completed", Client);
-                    else
-                        Logger.DebugLog("Xfer download for asset " + download.VFileID.ToString() + " completed", Client);
-
-                    download.Success = true;
-                    lock (Transfers) Transfers.Remove(download.ID);
-
-                    if (OnXferReceived != null)
-                    {
-                        try { OnXferReceived(download); }
-                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                    }
-                }
-            }
-        }
-
-        #endregion Xfer Callbacks
-
-        #region Image Callbacks
-
-        /// <summary>
-        /// Handles the Image Data packet which includes the ID and Size of the image,
-        /// along with the first block of data for the image. If the image is small enough
-        /// there will be no additional packets
-        /// </summary>
-        private void ImageDataHandler(Packet packet, Simulator simulator)
-        {
-            ImageDataPacket data = (ImageDataPacket)packet;
-            ImageDownload transfer = null;
-
-            Logger.DebugLog(String.Format("ImageData: Size={0}, Packets={1}", data.ImageID.Size, data.ImageID.Packets));
-
-            lock (Transfers)
-            {
-                if (Transfers.ContainsKey(data.ImageID.ID))
-                {
-                    transfer = (ImageDownload)Transfers[data.ImageID.ID];
-
-                    // Don't set header information if we have already
-                    // received it (due to re-request)
-                    if (transfer.Size == 0)
-                    {
-                        //Client.DebugLog("Received first " + data.ImageData.Data.Length + " bytes for image " +
-                        //    data.ImageID.ID.ToString());
-
-                        if (OnImageReceiveProgress != null)
-                        {
-                            try { OnImageReceiveProgress(data.ImageID.ID, 0, data.ImageData.Data.Length, transfer.Size); }
-                            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                        }
-
-                        transfer.Codec = (ImageCodec)data.ImageID.Codec;
-                        transfer.PacketCount = data.ImageID.Packets;
-                        transfer.Size = (int)data.ImageID.Size;
-                        transfer.AssetData = new byte[transfer.Size];
-                        transfer.AssetType = AssetType.Texture;
-                        transfer.PacketsSeen = new SortedList<ushort, ushort>();
-                        Buffer.BlockCopy(data.ImageData.Data, 0, transfer.AssetData, 0, data.ImageData.Data.Length);
-                        transfer.InitialDataSize = data.ImageData.Data.Length;
-                        transfer.Transferred += data.ImageData.Data.Length;
-			            
-                        // Check if we downloaded the full image
-                        if (transfer.Transferred >= transfer.Size)
-                        {
-                            Transfers.Remove(transfer.ID);
-                            transfer.Success = true;
-                            Cache.SaveImageToCache(transfer.ID, transfer.AssetData);
-                        }
-                    }
-                }
-            }
-
-            if (transfer != null)
-            {
-                transfer.HeaderReceivedEvent.Set();
-
-                if (OnImageReceived != null && transfer.Transferred >= transfer.Size)
-                {
-                    AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
-
-                    try { OnImageReceived(transfer, asset); }
-                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                }
-            }
-        }
-
-        /// <summary>
-        /// Handles the remaining Image data that did not fit in the initial ImageData packet
-        /// </summary>
-        private void ImagePacketHandler(Packet packet, Simulator simulator)
-        {
-            ImagePacketPacket image = (ImagePacketPacket)packet;
-            ImageDownload transfer = null;
-
-            lock (Transfers)
-            {
-                if (Transfers.ContainsKey(image.ImageID.ID))
-                {
-                    transfer = (ImageDownload)Transfers[image.ImageID.ID];
-
-                    if (transfer.Size == 0)
-                    {
-                        // We haven't received the header yet, block until it's received or times out
-                        transfer.HeaderReceivedEvent.WaitOne(1000 * 5, false);
-
-                        if (transfer.Size == 0)
-                        {
-                            Logger.Log("Timed out while waiting for the image header to download for " +
-                                transfer.ID.ToString(), Helpers.LogLevel.Warning, Client);
-
-                            transfer.Success = false;
-                            Transfers.Remove(transfer.ID);
-                            goto Callback;
-                        }
-                    }
-
-                    // The header is downloaded, we can insert this data in to the proper position
-                    // Only insert if we haven't seen this packet before
-                    lock (transfer.PacketsSeen)
-                    {
-                        if (!transfer.PacketsSeen.ContainsKey(image.ImageID.Packet))
-                        {
-                            transfer.PacketsSeen[image.ImageID.Packet] = image.ImageID.Packet;
-                            Buffer.BlockCopy(image.ImageData.Data, 0, transfer.AssetData,
-                                transfer.InitialDataSize + (1000 * (image.ImageID.Packet - 1)),
-                                image.ImageData.Data.Length);
-                            transfer.Transferred += image.ImageData.Data.Length;
-                        }
-                    }
-
-                    //Client.DebugLog("Received " + image.ImageData.Data.Length + "/" + transfer.Transferred +
-                    //    "/" + transfer.Size + " bytes for image " + image.ImageID.ID.ToString());
-
-                    transfer.TimeSinceLastPacket = 0;
-                    
-                    if (OnImageReceiveProgress != null)
-                    {
-                        try { OnImageReceiveProgress(image.ImageID.ID, image.ImageID.Packet, transfer.Transferred, transfer.Size); }
-                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-                    }
-
-                    // Check if we downloaded the full image
-                    if (transfer.Transferred >= transfer.Size)
-                    {
-                        Cache.SaveImageToCache(transfer.ID, transfer.AssetData);
-                        transfer.Success = true;
-                        Transfers.Remove(transfer.ID);
-                    }
-                }
-            }
-
-        Callback:
-
-            if (transfer != null && OnImageReceived != null && (transfer.Transferred >= transfer.Size || transfer.Size == 0))
-            {
-                AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
-
-                try { OnImageReceived(transfer, asset); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-            }
-        }
-
-        /// <summary>
-        /// The requested image does not exist on the asset server
-        /// </summary>
-        private void ImageNotInDatabaseHandler(Packet packet, Simulator simulator)
-        {
-            ImageNotInDatabasePacket notin = (ImageNotInDatabasePacket)packet;
-            ImageDownload transfer = null;
-
-            lock (Transfers)
-            {
-                if (Transfers.ContainsKey(notin.ImageID.ID))
-                {
-                    transfer = (ImageDownload)Transfers[notin.ImageID.ID];
-                    transfer.NotFound = true;
-                    Transfers.Remove(transfer.ID);
-                }
-            }
-
-            // Fire the event with our transfer that contains Success = false;
-            if (transfer != null && OnImageReceived != null)
-            {
-                try { OnImageReceived(transfer, null); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-            }
-        }
-
-        #endregion Image Callbacks
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+using System.Threading;
+using System.IO;
+using OpenMetaverse;
+using OpenMetaverse.Packets;
+
+namespace OpenMetaverse
+{
+    #region Enums
+
+    /// <summary>
+    /// The different types of grid assets
+    /// </summary>
+    public enum AssetType : sbyte
+    {
+        /// <summary>Unknown asset type</summary>
+        Unknown = -1,
+        /// <summary>Texture asset, stores in JPEG2000 J2C stream format</summary>
+        Texture = 0,
+        /// <summary>Sound asset</summary>
+        Sound = 1,
+        /// <summary>Calling card for another avatar</summary>
+        CallingCard = 2,
+        /// <summary>Link to a location in world</summary>
+        Landmark = 3,
+        // <summary>Legacy script asset, you should never see one of these</summary>
+        //[Obsolete]
+        //Script = 4,
+        /// <summary>Collection of textures and parameters that can be 
+        /// worn by an avatar</summary>
+        Clothing = 5,
+        /// <summary>Primitive that can contain textures, sounds, 
+        /// scripts and more</summary>
+        Object = 6,
+        /// <summary>Notecard asset</summary>
+        Notecard = 7,
+        /// <summary>Holds a collection of inventory items</summary>
+        Folder = 8,
+        /// <summary>Root inventory folder</summary>
+        RootFolder = 9,
+        /// <summary>Linden scripting language script</summary>
+        LSLText = 10,
+        /// <summary>LSO bytecode for a script</summary>
+        LSLBytecode = 11,
+        /// <summary>Uncompressed TGA texture</summary>
+        TextureTGA = 12,
+        /// <summary>Collection of textures and shape parameters that can
+        /// be worn</summary>
+        Bodypart = 13,
+        /// <summary>Trash folder</summary>
+        TrashFolder = 14,
+        /// <summary>Snapshot folder</summary>
+        SnapshotFolder = 15,
+        /// <summary>Lost and found folder</summary>
+        LostAndFoundFolder = 16,
+        /// <summary>Uncompressed sound</summary>
+        SoundWAV = 17,
+        /// <summary>Uncompressed TGA non-square image, not to be used as a
+        /// texture</summary>
+        ImageTGA = 18,
+        /// <summary>Compressed JPEG non-square image, not to be used as a
+        /// texture</summary>
+        ImageJPEG = 19,
+        /// <summary>Animation</summary>
+        Animation = 20,
+        /// <summary>Sequence of animations, sounds, chat, and pauses</summary>
+        Gesture = 21,
+        /// <summary>Simstate file</summary>
+        Simstate = 22,
+    }
+
+    public enum EstateAssetType : int
+    {
+        None = -1,
+        Covenant = 0
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public enum StatusCode
+    {
+        /// <summary>OK</summary>
+        OK = 0,
+        /// <summary>Transfer completed</summary>
+        Done = 1,
+        /// <summary></summary>
+        Skip = 2,
+        /// <summary></summary>
+        Abort = 3,
+        /// <summary>Unknown error occurred</summary>
+        Error = -1,
+        /// <summary>Equivalent to a 404 error</summary>
+        UnknownSource = -2,
+        /// <summary>Client does not have permission for that resource</summary>
+        InsufficientPermissiosn = -3,
+        /// <summary>Unknown status</summary>
+        Unknown = -4
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public enum ChannelType : int
+    {
+        /// <summary></summary>
+        Unknown = 0,
+        /// <summary>Unknown</summary>
+        Misc = 1,
+        /// <summary>Virtually all asset transfers use this channel</summary>
+        Asset = 2
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public enum SourceType : int
+    {
+        /// <summary></summary>
+        Unknown = 0,
+        /// <summary>Asset from the asset server</summary>
+        Asset = 2,
+        /// <summary>Inventory item</summary>
+        SimInventoryItem = 3,
+        /// <summary>Estate asset, such as an estate covenant</summary>
+        SimEstate = 4
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public enum TargetType : int
+    {
+        /// <summary></summary>
+        Unknown = 0,
+        /// <summary></summary>
+        File = 1,
+        /// <summary></summary>
+        VFile = 2
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public enum ImageType : byte
+    {
+        /// <summary></summary>
+        Normal = 0,
+        /// <summary></summary>
+        Baked = 1
+    }
+
+    /// <summary>
+    /// Image file format
+    /// </summary>
+    public enum ImageCodec : byte
+    {
+        Invalid = 0,
+        RGB = 1,
+        J2C = 2,
+        BMP = 3,
+        TGA = 4,
+        JPEG = 5,
+        DXT = 6,
+        PNG = 7
+    }
+
+    public enum TransferError : int
+    {
+        None = 0,
+        Failed = -1,
+        AssetNotFound = -3,
+        AssetNotFoundInDatabase = -4,
+        InsufficientPermissions = -5,
+        EOF = -39,
+        CannotOpenFile = -42,
+        FileNotFound = -43,
+        FileIsEmpty = -44,
+        TCPTimeout = -23016,
+        CircuitGone = -23017
+    }
+
+    #endregion Enums
+
+    #region Transfer Classes
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public class Transfer
+    {
+        public UUID ID;
+        public int Size;
+        public byte[] AssetData = new byte[0];
+        public int Transferred;
+        public bool Success;
+        public AssetType AssetType;
+
+        private int transferStart;
+
+        /// <summary>Number of milliseconds passed since the last transfer
+        /// packet was received</summary>
+        public int TimeSinceLastPacket
+        {
+            get { return Environment.TickCount - transferStart; }
+            internal set { transferStart = Environment.TickCount + value; }
+        }
+
+        public Transfer()
+        {
+            AssetData = new byte[0];
+            transferStart = Environment.TickCount;
+        }
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public class AssetDownload : Transfer
+    {
+        public UUID AssetID;
+        public ChannelType Channel;
+        public SourceType Source;
+        public TargetType Target;
+        public StatusCode Status;
+        public float Priority;
+        public Simulator Simulator;
+
+        internal AutoResetEvent HeaderReceivedEvent = new AutoResetEvent(false);
+
+        public AssetDownload()
+            : base()
+        {
+        }
+    }
+
+    public class XferDownload : Transfer
+    {
+        public ulong XferID;
+        public UUID VFileID;
+        public AssetType Type;
+        public uint PacketNum;
+        public string Filename = String.Empty;
+
+        public XferDownload()
+            : base()
+        {
+        }
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public class ImageDownload : Transfer
+    {
+        public ushort PacketCount;
+        public ImageCodec Codec;
+        public bool NotFound;
+        public Simulator Simulator;
+        public SortedList<ushort, ushort> PacketsSeen;
+        public ImageType ImageType;
+        public int DiscardLevel;
+        public float Priority;
+
+        internal int InitialDataSize;
+        internal AutoResetEvent HeaderReceivedEvent = new AutoResetEvent(false);
+
+        public ImageDownload()
+            : base()
+        {
+        }
+    }
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public class AssetUpload : Transfer
+    {
+        public UUID AssetID;
+        public AssetType Type;
+        public ulong XferID;
+        public uint PacketNum;
+
+        public AssetUpload()
+            : base()
+        {
+        }
+    }
+
+    public class ImageRequest
+    {
+        public ImageRequest(UUID imageid, ImageType type, float priority, int discardLevel)
+        {
+            ImageID = imageid;
+            Type = type;
+            Priority = priority;
+            DiscardLevel = discardLevel;
+        }
+        public UUID ImageID;
+        public ImageType Type;
+        public float Priority;
+        public int DiscardLevel;
+    }
+    #endregion Transfer Classes
+
+    /// <summary>
+    /// 
+    /// </summary>
+    public class AssetManager
+    {
+        #region Delegates
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="transfer"></param>
+        /// <param name="asset"></param>
+        public delegate void AssetReceivedCallback(AssetDownload transfer, Asset asset);
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="xfer"></param>
+        public delegate void XferReceivedCallback(XferDownload xfer);
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="image"></param>
+        /// <param name="asset"></param>
+        public delegate void ImageReceivedCallback(ImageDownload image, AssetTexture asset);
+        /// <summary>
+        /// 
+        /// </summary>
+        public delegate void ImageReceiveProgressCallback(UUID image, int lastPacket, int recieved, int total);
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="upload"></param>
+        public delegate void AssetUploadedCallback(AssetUpload upload);
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="upload"></param>
+        public delegate void UploadProgressCallback(AssetUpload upload);
+
+        #endregion Delegates
+
+        #region Events
+
+        /// <summary></summary>
+        public event AssetReceivedCallback OnAssetReceived;
+        /// <summary></summary>
+        public event XferReceivedCallback OnXferReceived;
+        /// <summary></summary>
+        public event ImageReceivedCallback OnImageReceived;
+        /// <summary></summary>
+        public event ImageReceiveProgressCallback OnImageReceiveProgress;
+        /// <summary></summary>
+        public event AssetUploadedCallback OnAssetUploaded;
+        /// <summary></summary>
+        public event UploadProgressCallback OnUploadProgress;
+
+        #endregion Events
+
+        /// <summary>Texture download cache</summary>
+        public TextureCache Cache;
+
+        private GridClient Client;
+        private Dictionary<UUID, Transfer> Transfers = new Dictionary<UUID, Transfer>();
+        private AssetUpload PendingUpload;
+        private object PendingUploadLock = new object();
+        private volatile bool WaitingForUploadConfirm = false;
+        private System.Timers.Timer RefreshDownloadsTimer = new System.Timers.Timer(500.0);
+        
+        /// <summary>
+        /// Default constructor
+        /// </summary>
+        /// <param name="client">A reference to the GridClient object</param>
+        public AssetManager(GridClient client)
+        {
+            Client = client;
+            Cache = new TextureCache(client);
+
+            // Transfer packets for downloading large assets
+            Client.Network.RegisterCallback(PacketType.TransferInfo, new NetworkManager.PacketCallback(TransferInfoHandler));
+            Client.Network.RegisterCallback(PacketType.TransferPacket, new NetworkManager.PacketCallback(TransferPacketHandler));
+
+            // Image downloading packets
+            Client.Network.RegisterCallback(PacketType.ImageData, new NetworkManager.PacketCallback(ImageDataHandler));
+            Client.Network.RegisterCallback(PacketType.ImagePacket, new NetworkManager.PacketCallback(ImagePacketHandler));
+            Client.Network.RegisterCallback(PacketType.ImageNotInDatabase, new NetworkManager.PacketCallback(ImageNotInDatabaseHandler));
+
+            // Xfer packets for uploading large assets
+            Client.Network.RegisterCallback(PacketType.RequestXfer, new NetworkManager.PacketCallback(RequestXferHandler));
+            Client.Network.RegisterCallback(PacketType.ConfirmXferPacket, new NetworkManager.PacketCallback(ConfirmXferPacketHandler));
+            Client.Network.RegisterCallback(PacketType.AssetUploadComplete, new NetworkManager.PacketCallback(AssetUploadCompleteHandler));
+
+            // Xfer packet for downloading misc assets
+            Client.Network.RegisterCallback(PacketType.SendXferPacket, new NetworkManager.PacketCallback(SendXferPacketHandler));
+
+            // HACK: Re-request stale pending image downloads
+            RefreshDownloadsTimer.Elapsed += new System.Timers.ElapsedEventHandler(RefreshDownloadsTimer_Elapsed);
+            RefreshDownloadsTimer.Start();
+        }
+
+        private void RefreshDownloadsTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
+        {
+            lock (Transfers)
+            {
+                foreach (Transfer transfer in Transfers.Values)
+                {
+                    if (transfer is ImageDownload)
+                    {
+                        ImageDownload download = (ImageDownload)transfer;
+
+                        uint packet = 0;
+                        
+                        if (download.PacketsSeen != null && download.PacketsSeen.Count > 0)
+                        {
+                            lock (download.PacketsSeen)
+                            {
+                                bool first = true;
+                                foreach (KeyValuePair<ushort, ushort> packetSeen in download.PacketsSeen)
+                                {
+                                    if (first)
+                                    {
+                                        // Initially set this to the earliest packet received in the transfer
+                                        packet = packetSeen.Value;
+                                        first = false;
+                                    }
+                                    else
+                                    {
+                                        ++packet;
+
+                                        // If there is a missing packet in the list, break and request the download
+                                        // resume here
+                                        if (packetSeen.Value != packet)
+                                        {
+                                            --packet;
+                                            break;
+                                        }
+                                    }
+                                }
+
+                                ++packet;
+                            }
+                        }
+
+                        if (download.TimeSinceLastPacket > 5000)
+                        {
+                            --download.DiscardLevel;
+                            download.TimeSinceLastPacket = 0;
+                            RequestImage(download.ID, download.ImageType, download.Priority, download.DiscardLevel, packet);
+                        }
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Request an asset download
+        /// </summary>
+        /// <param name="assetID">Asset UUID</param>
+        /// <param name="type">Asset type, must be correct for the transfer to succeed</param>
+        /// <param name="priority">Whether to give this transfer an elevated priority</param>
+        /// <returns>The transaction ID generated for this transfer</returns>
+        public UUID RequestAsset(UUID assetID, AssetType type, bool priority)
+        {
+            AssetDownload transfer = new AssetDownload();
+            transfer.ID = UUID.Random();
+            transfer.AssetID = assetID;
+            //transfer.AssetType = type; // Set in TransferInfoHandler.
+            transfer.Priority = 100.0f + (priority ? 1.0f : 0.0f);
+            transfer.Channel = ChannelType.Asset;
+            transfer.Source = SourceType.Asset;
+            transfer.Simulator = Client.Network.CurrentSim;
+
+            // Add this transfer to the dictionary
+            lock (Transfers) Transfers[transfer.ID] = transfer;
+
+            // Build the request packet and send it
+            TransferRequestPacket request = new TransferRequestPacket();
+            request.TransferInfo.ChannelType = (int)transfer.Channel;
+            request.TransferInfo.Priority = transfer.Priority;
+            request.TransferInfo.SourceType = (int)transfer.Source;
+            request.TransferInfo.TransferID = transfer.ID;
+
+            byte[] paramField = new byte[20];
+            Buffer.BlockCopy(assetID.GetBytes(), 0, paramField, 0, 16);
+            Buffer.BlockCopy(Utils.IntToBytes((int)type), 0, paramField, 16, 4);
+            request.TransferInfo.Params = paramField;
+
+            Client.Network.SendPacket(request, transfer.Simulator);
+            return transfer.ID;
+        }
+
+        /// <summary>
+        /// Request an asset download through the almost deprecated Xfer system
+        /// </summary>
+        /// <param name="filename">Filename of the asset to request</param>
+        /// <param name="deleteOnCompletion">Whether or not to delete the asset
+        /// off the server after it is retrieved</param>
+        /// <param name="useBigPackets">Use large transfer packets or not</param>
+        /// <param name="vFileID">UUID of the file to request, if filename is
+        /// left empty</param>
+        /// <param name="vFileType">Asset type of <code>vFileID</code>, or
+        /// <code>AssetType.Unknown</code> if filename is not empty</param>
+        /// <param name="fromCache">Sets the FilePath in the request to Cache
+        /// (4) if true, otherwise Unknown (0) is used</param>
+        /// <returns></returns>
+        public ulong RequestAssetXfer(string filename, bool deleteOnCompletion, bool useBigPackets, UUID vFileID, AssetType vFileType,
+            bool fromCache)
+        {
+            UUID uuid = UUID.Random();
+            ulong id = uuid.GetULong();
+
+            XferDownload transfer = new XferDownload();
+            transfer.XferID = id;
+            transfer.ID = new UUID(id); // Our dictionary tracks transfers with UUIDs, so convert the ulong back
+            transfer.Filename = filename;
+            transfer.VFileID = vFileID;
+            transfer.AssetType = vFileType;
+
+            // Add this transfer to the dictionary
+            lock (Transfers) Transfers[transfer.ID] = transfer;
+
+            RequestXferPacket request = new RequestXferPacket();
+            request.XferID.ID = id;
+            request.XferID.Filename = Utils.StringToBytes(filename);
+            request.XferID.FilePath = fromCache ? (byte)4 : (byte)0;
+            request.XferID.DeleteOnCompletion = deleteOnCompletion;
+            request.XferID.UseBigPackets = useBigPackets;
+            request.XferID.VFileID = vFileID;
+            request.XferID.VFileType = (short)vFileType;
+
+            Client.Network.SendPacket(request);
+
+            return id;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <param name="assetID">Use UUID.Zero if you do not have the 
+        /// asset ID but have all the necessary permissions</param>
+        /// <param name="itemID">The item ID of this asset in the inventory</param>
+        /// <param name="taskID">Use UUID.Zero if you are not requesting an 
+        /// asset from an object inventory</param>
+        /// <param name="ownerID">The owner of this asset</param>
+        /// <param name="type">Asset type</param>
+        /// <param name="priority">Whether to prioritize this asset download or not</param>
+        public UUID RequestInventoryAsset(UUID assetID, UUID itemID, UUID taskID, UUID ownerID, AssetType type, bool priority)
+        {
+            AssetDownload transfer = new AssetDownload();
+            transfer.ID = UUID.Random();
+            transfer.AssetID = assetID;
+            //transfer.AssetType = type; // Set in TransferInfoHandler.
+            transfer.Priority = 100.0f + (priority ? 1.0f : 0.0f);
+            transfer.Channel = ChannelType.Asset;
+            transfer.Source = SourceType.SimInventoryItem;
+            transfer.Simulator = Client.Network.CurrentSim;
+
+            // Add this transfer to the dictionary
+            lock (Transfers) Transfers[transfer.ID] = transfer;
+
+            // Build the request packet and send it
+            TransferRequestPacket request = new TransferRequestPacket();
+            request.TransferInfo.ChannelType = (int)transfer.Channel;
+            request.TransferInfo.Priority = transfer.Priority;
+            request.TransferInfo.SourceType = (int)transfer.Source;
+            request.TransferInfo.TransferID = transfer.ID;
+
+            byte[] paramField = new byte[100];
+            Buffer.BlockCopy(Client.Self.AgentID.GetBytes(), 0, paramField, 0, 16);
+            Buffer.BlockCopy(Client.Self.SessionID.GetBytes(), 0, paramField, 16, 16);
+            Buffer.BlockCopy(ownerID.GetBytes(), 0, paramField, 32, 16);
+            Buffer.BlockCopy(taskID.GetBytes(), 0, paramField, 48, 16);
+            Buffer.BlockCopy(itemID.GetBytes(), 0, paramField, 64, 16);
+            Buffer.BlockCopy(assetID.GetBytes(), 0, paramField, 80, 16);
+            Buffer.BlockCopy(Utils.IntToBytes((int)type), 0, paramField, 96, 4);
+            request.TransferInfo.Params = paramField;
+
+            Client.Network.SendPacket(request, transfer.Simulator);
+            return transfer.ID;
+        }
+
+        public UUID RequestInventoryAsset(InventoryItem item, bool priority)
+        {
+            return RequestInventoryAsset(item.AssetUUID, item.UUID, UUID.Zero, item.OwnerID, item.AssetType, priority);
+        }
+
+        public void RequestEstateAsset()
+        {
+            throw new Exception("This function is not implemented yet!");
+        }
+
+        /// <summary>
+        /// Initiate an image download. This is an asynchronous function
+        /// </summary>
+        /// <param name="imageID">The image to download</param>
+        /// <param name="type">Type of the image to download, either a baked
+        /// avatar texture or a normal texture</param>
+        public void RequestImage(UUID imageID, ImageType type)
+        {
+            RequestImage(imageID, type, 1013000.0f, 0, 0);
+        }
+
+        /// <summary>
+        /// Initiate an image download. This is an asynchronous function
+        /// </summary>
+        /// <param name="imageID">The image to download</param>
+        /// <param name="type">Type of the image to download, either a baked
+        /// avatar texture or a normal texture</param>
+        /// <param name="priority">Priority level of the download. Default is
+        /// <c>1,013,000.0f</c></param>
+        /// <param name="discardLevel">Number of quality layers to discard.
+        /// This controls the end marker of the data sent</param>
+        /// <param name="packetNum">Packet number to start the download at.
+        /// This controls the start marker of the data sent</param>
+        /// <remarks>Sending a priority of 0 and a discardlevel of -1 aborts
+        /// download</remarks>
+        public void RequestImage(UUID imageID, ImageType type, float priority, int discardLevel, uint packetNum)
+        {
+            if (Cache.HasImage(imageID))
+            {
+                ImageDownload transfer = Cache.GetCachedImage(imageID);
+                transfer.ImageType = type;
+
+                if (null != transfer)
+                {
+                    if (null != OnImageReceived)
+                    {
+                        AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
+
+                        try { OnImageReceived(transfer, asset); }
+                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                    }
+                    return;
+                }
+            }
+
+            // Priority == 0 && DiscardLevel == -1 means cancel the transfer
+            if (priority.Equals(0) && discardLevel.Equals(-1))
+            {
+                if (Transfers.ContainsKey(imageID))
+                    Transfers.Remove(imageID);
+
+                RequestImagePacket cancel = new RequestImagePacket();
+                cancel.AgentData.AgentID = Client.Self.AgentID;
+                cancel.AgentData.SessionID = Client.Self.SessionID;
+                cancel.RequestImage = new RequestImagePacket.RequestImageBlock[1];
+                cancel.RequestImage[0] = new RequestImagePacket.RequestImageBlock();
+                cancel.RequestImage[0].DiscardLevel = -1;
+                cancel.RequestImage[0].DownloadPriority = 0;
+                cancel.RequestImage[0].Packet = 0;
+                cancel.RequestImage[0].Image = imageID;
+                cancel.RequestImage[0].Type = 0;
+            }
+            else
+            {
+                Simulator currentSim = Client.Network.CurrentSim;
+
+                if (!Transfers.ContainsKey(imageID))
+                {
+                    // New download
+                    ImageDownload transfer = new ImageDownload();
+                    transfer.ID = imageID;
+                    transfer.Simulator = currentSim;
+                    transfer.ImageType = type;
+                    transfer.DiscardLevel = discardLevel;
+                    transfer.Priority = priority;
+
+                    // Add this transfer to the dictionary
+                    lock (Transfers) Transfers[transfer.ID] = transfer;
+
+                    Logger.DebugLog("Adding image " + imageID.ToString() + " to the download queue");
+                }
+                else
+                {
+                    // Already downloading, just updating the priority
+                    Transfer transfer = Transfers[imageID];
+                    float percentComplete = ((float)transfer.Transferred / (float)transfer.Size) * 100f;
+                    if (Single.IsNaN(percentComplete))
+                        percentComplete = 0f;
+
+                    Logger.DebugLog(String.Format("Updating priority on image transfer {0}, {1}% complete",
+                        imageID, Math.Round(percentComplete, 2)));
+                }
+
+                // Build and send the request packet
+                RequestImagePacket request = new RequestImagePacket();
+                request.AgentData.AgentID = Client.Self.AgentID;
+                request.AgentData.SessionID = Client.Self.SessionID;
+                request.RequestImage = new RequestImagePacket.RequestImageBlock[1];
+                request.RequestImage[0] = new RequestImagePacket.RequestImageBlock();
+                request.RequestImage[0].DiscardLevel = (sbyte)discardLevel;
+                request.RequestImage[0].DownloadPriority = priority;
+                request.RequestImage[0].Packet = packetNum;
+                request.RequestImage[0].Image = imageID;
+                request.RequestImage[0].Type = (byte)type;
+
+                Client.Network.SendPacket(request, currentSim);
+            }
+        }
+
+        /// <summary>
+        /// Requests multiple Images
+        /// </summary>
+        /// <param name="Images">List of requested images</param>
+        public void RequestImages(List<ImageRequest> Images)
+        {
+            for (int iri = 0; iri < Images.Count; iri++)
+            {
+                if (Transfers.ContainsKey(Images[iri].ImageID))
+                {
+                    Images.RemoveAt(iri);
+                }
+
+                if (Cache.HasImage(Images[iri].ImageID))
+                {
+                    ImageDownload transfer = Cache.GetCachedImage(Images[iri].ImageID);
+                    if (null != transfer)
+                    {
+                        if (null != OnImageReceived)
+                        {
+                            AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
+
+                            try { OnImageReceived(transfer, asset); }
+                            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                        }
+
+                        Images.RemoveAt(iri);
+                    }
+                }
+            }
+
+            if (Images.Count > 0)
+            {
+                // Build and send the request packet
+                RequestImagePacket request = new RequestImagePacket();
+                request.AgentData.AgentID = Client.Self.AgentID;
+                request.AgentData.SessionID = Client.Self.SessionID;
+                request.RequestImage = new RequestImagePacket.RequestImageBlock[Images.Count];
+
+                for (int iru = 0; iru < Images.Count; ++iru)
+                {
+                    ImageDownload transfer = new ImageDownload();
+                    //transfer.AssetType = AssetType.Texture // Handled in ImageDataHandler.
+                    transfer.ID = Images[iru].ImageID;
+                    transfer.Simulator = Client.Network.CurrentSim;
+                    transfer.ImageType = Images[iru].Type;
+                    transfer.DiscardLevel = Images[iru].DiscardLevel;
+                    transfer.Priority = Images[iru].Priority;
+
+                    // Add this transfer to the dictionary
+                    lock (Transfers) Transfers[transfer.ID] = transfer;
+                    request.RequestImage[iru] = new RequestImagePacket.RequestImageBlock();
+                    request.RequestImage[iru].DiscardLevel = (sbyte)Images[iru].DiscardLevel;
+                    request.RequestImage[iru].DownloadPriority = Images[iru].Priority;
+                    request.RequestImage[iru].Packet = 0;
+                    request.RequestImage[iru].Image = Images[iru].ImageID;
+                    request.RequestImage[iru].Type = (byte)Images[iru].Type;
+                }
+
+                Client.Network.SendPacket(request, Client.Network.CurrentSim);
+            }
+            else
+            {
+                Logger.Log("RequestImages() called for an image(s) we are already downloading or an empty list, ignoring",
+                    Helpers.LogLevel.Info, Client);
+            }
+        }
+
+        public UUID RequestUpload(Asset asset, bool storeLocal)
+        {
+            if (asset.AssetData == null)
+                throw new ArgumentException("Can't upload an asset with no data (did you forget to call Encode?)");
+
+            UUID assetID;
+            UUID transferID = RequestUpload(out assetID, asset.AssetType, asset.AssetData, storeLocal);
+            asset.AssetID = assetID;
+            return transferID;
+        }
+        
+        public UUID RequestUpload(AssetType type, byte[] data, bool storeLocal)
+        {
+            UUID assetID;
+            return RequestUpload(out assetID, type, data, storeLocal);
+        }
+
+        /// <summary>
+        /// Initiate an asset upload
+        /// </summary>
+        /// <param name="assetID">The ID this asset will have if the
+        /// upload succeeds</param>
+        /// <param name="type">Asset type to upload this data as</param>
+        /// <param name="data">Raw asset data to upload</param>
+        /// <param name="storeLocal">Whether to store this asset on the local
+        /// simulator or the grid-wide asset server</param>
+        /// <returns>The transaction ID of this transfer</returns>
+        public UUID RequestUpload(out UUID assetID, AssetType type, byte[] data, bool storeLocal)
+        {
+            AssetUpload upload = new AssetUpload();
+            upload.AssetData = data;
+            upload.AssetType = type;
+            upload.ID = UUID.Random();
+            assetID = UUID.Combine(upload.ID, Client.Self.SecureSessionID);
+            upload.AssetID = assetID;
+            upload.Size = data.Length;
+            upload.XferID = 0;
+
+            Transfers[upload.ID]=upload;
+
+            // Build and send the upload packet
+            AssetUploadRequestPacket request = new AssetUploadRequestPacket();
+            request.AssetBlock.StoreLocal = storeLocal;
+            request.AssetBlock.Tempfile = false; // This field is deprecated
+            request.AssetBlock.TransactionID = upload.ID;
+            request.AssetBlock.Type = (sbyte)type;
+
+            if (data.Length + 100 < Settings.MAX_PACKET_SIZE)
+            {
+                Logger.Log(
+                    String.Format("Beginning asset upload [Single Packet], ID: {0}, AssetID: {1}, Size: {2}",
+                    upload.ID.ToString(), upload.AssetID.ToString(), upload.Size), Helpers.LogLevel.Info, Client);
+
+                // The whole asset will fit in this packet, makes things easy
+                request.AssetBlock.AssetData = data;
+                upload.Transferred = data.Length;
+            }
+            else
+            {
+                Logger.Log(
+                    String.Format("Beginning asset upload [Multiple Packets], ID: {0}, AssetID: {1}, Size: {2}",
+                    upload.ID.ToString(), upload.AssetID.ToString(), upload.Size), Helpers.LogLevel.Info, Client);
+
+                // Asset is too big, send in multiple packets
+                request.AssetBlock.AssetData = new byte[0];
+            }
+
+            // Wait for the previous upload to receive a RequestXferPacket
+            lock (PendingUploadLock)
+            {
+                const int UPLOAD_CONFIRM_TIMEOUT = 10000;
+                const int SLEEP_INTERVAL = 50;
+                int t = 0;
+                while (WaitingForUploadConfirm && t < UPLOAD_CONFIRM_TIMEOUT)
+                {
+                    System.Threading.Thread.Sleep(SLEEP_INTERVAL);
+                    t += SLEEP_INTERVAL;
+                }
+
+                if (t < UPLOAD_CONFIRM_TIMEOUT)
+                {
+                    WaitingForUploadConfirm = true;
+                    PendingUpload = upload;
+                    Client.Network.SendPacket(request);
+
+                    return upload.ID;
+                }
+                else
+                {
+                    throw new Exception("Timeout waiting for previous asset upload to begin");
+                }
+            }
+        }
+
+        #region Helpers
+
+        private Asset CreateAssetWrapper(AssetType type)
+        {
+            Asset asset;
+
+            switch (type)
+            {
+                case AssetType.Notecard:
+                    asset = new AssetNotecard();
+                    break;
+                case AssetType.LSLText:
+                    asset = new AssetScriptText();
+                    break;
+                case AssetType.LSLBytecode:
+                    asset = new AssetScriptBinary();
+                    break;
+                case AssetType.Texture:
+                    asset = new AssetTexture();
+                    break;
+                case AssetType.Object:
+                    asset = new AssetPrim();
+                    break;
+                case AssetType.Clothing:
+                    asset = new AssetClothing();
+                    break;
+                case AssetType.Bodypart:
+                    asset = new AssetBodypart();
+                    break;
+                case AssetType.Animation:
+                    asset = new AssetAnimation();
+                    break;
+                case AssetType.Sound:
+                    asset = new AssetSound();
+                    break;
+                default:
+                    Logger.Log("Unimplemented asset type: " + type, Helpers.LogLevel.Error, Client);
+                    return null;
+            }
+
+            return asset;
+        }
+
+        private Asset WrapAsset(AssetDownload download)
+        {
+            Asset asset = CreateAssetWrapper(download.AssetType);
+            if (asset != null)
+            {
+                asset.AssetID = download.AssetID;
+                asset.AssetData = download.AssetData;
+                return asset;
+            }
+            else
+            {
+                return null;
+            }
+        }
+
+        private void SendNextUploadPacket(AssetUpload upload)
+        {
+            SendXferPacketPacket send = new SendXferPacketPacket();
+
+            send.XferID.ID = upload.XferID;
+            send.XferID.Packet = upload.PacketNum++;
+
+            if (send.XferID.Packet == 0)
+            {
+                // The first packet reserves the first four bytes of the data for the
+                // total length of the asset and appends 1000 bytes of data after that
+                send.DataPacket.Data = new byte[1004];
+                Buffer.BlockCopy(Utils.IntToBytes(upload.Size), 0, send.DataPacket.Data, 0, 4);
+                Buffer.BlockCopy(upload.AssetData, 0, send.DataPacket.Data, 4, 1000);
+                upload.Transferred += 1000;
+
+                lock (Transfers)
+                {
+                    Transfers.Remove(upload.AssetID);
+                    Transfers[upload.ID] = upload;
+                }
+            }
+            else if ((send.XferID.Packet + 1) * 1000 < upload.Size)
+            {
+                // This packet is somewhere in the middle of the transfer, or a perfectly
+                // aligned packet at the end of the transfer
+                send.DataPacket.Data = new byte[1000];
+                Buffer.BlockCopy(upload.AssetData, upload.Transferred, send.DataPacket.Data, 0, 1000);
+                upload.Transferred += 1000;
+            }
+            else
+            {
+                // Special handler for the last packet which will be less than 1000 bytes
+                int lastlen = upload.Size - ((int)send.XferID.Packet * 1000);
+                send.DataPacket.Data = new byte[lastlen];
+                Buffer.BlockCopy(upload.AssetData, (int)send.XferID.Packet * 1000, send.DataPacket.Data, 0, lastlen);
+                send.XferID.Packet |= (uint)0x80000000; // This signals the final packet
+                upload.Transferred += lastlen;
+            }
+
+            Client.Network.SendPacket(send);
+        }
+
+        private void SendConfirmXferPacket(ulong xferID, uint packetNum)
+        {
+            ConfirmXferPacketPacket confirm = new ConfirmXferPacketPacket();
+            confirm.XferID.ID = xferID;
+            confirm.XferID.Packet = packetNum;
+
+            Client.Network.SendPacket(confirm);
+        }
+
+        #endregion Helpers
+
+        #region Transfer Callbacks
+
+        private void TransferInfoHandler(Packet packet, Simulator simulator)
+        {
+            if (OnAssetReceived != null)
+            {
+                TransferInfoPacket info = (TransferInfoPacket)packet;
+                Transfer transfer;
+                AssetDownload download;
+
+                if (Transfers.TryGetValue(info.TransferInfo.TransferID, out transfer))
+                {
+                    download = (AssetDownload)transfer;
+
+                    download.Channel = (ChannelType)info.TransferInfo.ChannelType;
+                    download.Status = (StatusCode)info.TransferInfo.Status;
+                    download.Target = (TargetType)info.TransferInfo.TargetType;
+                    download.Size = info.TransferInfo.Size;
+
+                    // TODO: Once we support mid-transfer status checking and aborting this
+                    // will need to become smarter
+                    if (download.Status != StatusCode.OK)
+                    {
+                        Logger.Log("Transfer failed with status code " + download.Status, Helpers.LogLevel.Warning, Client);
+
+                        lock (Transfers) Transfers.Remove(download.ID);
+
+                        // No data could have been received before the TransferInfo packet
+                        download.AssetData = null;
+
+                        // Fire the event with our transfer that contains Success = false;
+                        try { OnAssetReceived(download, null); }
+                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                    }
+                    else
+                    {
+                        download.AssetData = new byte[download.Size];
+
+                        if (download.Source == SourceType.Asset && info.TransferInfo.Params.Length == 20)
+                        {
+                            download.AssetID = new UUID(info.TransferInfo.Params, 0);
+                            download.AssetType = (AssetType)(sbyte)info.TransferInfo.Params[16];
+
+                            //Client.DebugLog(String.Format("TransferInfo packet received. AssetID: {0} Type: {1}",
+                            //    transfer.AssetID, type));
+                        }
+                        else if (download.Source == SourceType.SimInventoryItem && info.TransferInfo.Params.Length == 100)
+                        {
+                            // TODO: Can we use these?
+                            //UUID agentID = new UUID(info.TransferInfo.Params, 0);
+                            //UUID sessionID = new UUID(info.TransferInfo.Params, 16);
+                            //UUID ownerID = new UUID(info.TransferInfo.Params, 32);
+                            //UUID taskID = new UUID(info.TransferInfo.Params, 48);
+                            //UUID itemID = new UUID(info.TransferInfo.Params, 64);
+                            download.AssetID = new UUID(info.TransferInfo.Params, 80);
+                            download.AssetType = (AssetType)(sbyte)info.TransferInfo.Params[96];
+
+                            //Client.DebugLog(String.Format("TransferInfo packet received. AgentID: {0} SessionID: {1} " + 
+                            //    "OwnerID: {2} TaskID: {3} ItemID: {4} AssetID: {5} Type: {6}", agentID, sessionID, 
+                            //    ownerID, taskID, itemID, transfer.AssetID, type));
+                        }
+                        else
+                        {
+                            Logger.Log("Received a TransferInfo packet with a SourceType of " + download.Source.ToString() +
+                                " and a Params field length of " + info.TransferInfo.Params.Length,
+                                Helpers.LogLevel.Warning, Client);
+                        }
+                    }
+                }
+                else
+                {
+                    Logger.Log("Received a TransferInfo packet for an asset we didn't request, TransferID: " +
+                        info.TransferInfo.TransferID, Helpers.LogLevel.Warning, Client);
+                }
+            }
+        }
+
+        private void TransferPacketHandler(Packet packet, Simulator simulator)
+        {
+            TransferPacketPacket asset = (TransferPacketPacket)packet;
+            Transfer transfer;
+            AssetDownload download;
+
+            if (Transfers.TryGetValue(asset.TransferData.TransferID, out transfer))
+            {
+                download = (AssetDownload)transfer;
+
+                if (download.Size == 0)
+                {
+                    Logger.DebugLog("TransferPacket received ahead of the transfer header, blocking...", Client);
+
+                    // We haven't received the header yet, block until it's received or times out
+                    download.HeaderReceivedEvent.WaitOne(1000 * 5, false);
+
+                    if (download.Size == 0)
+                    {
+                        Logger.Log("Timed out while waiting for the asset header to download for " +
+                            download.ID.ToString(), Helpers.LogLevel.Warning, Client);
+
+                        // Abort the transfer
+                        TransferAbortPacket abort = new TransferAbortPacket();
+                        abort.TransferInfo.ChannelType = (int)download.Channel;
+                        abort.TransferInfo.TransferID = download.ID;
+                        Client.Network.SendPacket(abort, download.Simulator);
+
+                        download.Success = false;
+                        lock (Transfers) Transfers.Remove(download.ID);
+
+                        // Fire the event with our transfer that contains Success = false
+                        if (OnAssetReceived != null)
+                        {
+                            try { OnAssetReceived(download, null); }
+                            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                        }
+
+                        return;
+                    }
+                }
+
+                // This assumes that every transfer packet except the last one is exactly 1000 bytes,
+                // hopefully that is a safe assumption to make
+                try
+                {
+                    Buffer.BlockCopy(asset.TransferData.Data, 0, download.AssetData, 1000 * asset.TransferData.Packet,
+                        asset.TransferData.Data.Length);
+                    download.Transferred += asset.TransferData.Data.Length;
+                }
+                catch (ArgumentException)
+                {
+                    Logger.Log(String.Format("TransferPacket handling failed. TransferData.Data.Length={0}, AssetData.Length={1}, TransferData.Packet={2}",
+                        asset.TransferData.Data.Length, download.AssetData.Length, asset.TransferData.Packet), Helpers.LogLevel.Error);
+                    return;
+                }
+
+                //Client.DebugLog(String.Format("Transfer packet {0}, received {1}/{2}/{3} bytes for asset {4}",
+                //    asset.TransferData.Packet, asset.TransferData.Data.Length, transfer.Transferred, transfer.Size,
+                //    transfer.AssetID.ToString()));
+
+                // Check if we downloaded the full asset
+                if (download.Transferred >= download.Size)
+                {
+                    Logger.DebugLog("Transfer for asset " + download.AssetID.ToString() + " completed", Client);
+
+                    download.Success = true;
+                    lock (Transfers) Transfers.Remove(download.ID);
+
+                    if (OnAssetReceived != null)
+                    {
+                        try { OnAssetReceived(download, WrapAsset(download)); }
+                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                    }
+                }
+            }
+        }
+
+        #endregion Transfer Callbacks
+
+        #region Xfer Callbacks
+
+        private void RequestXferHandler(Packet packet, Simulator simulator)
+        {
+            if (PendingUpload == null)
+                Logger.Log("Received a RequestXferPacket for an unknown asset upload", Helpers.LogLevel.Warning, Client);
+            else
+            {
+                AssetUpload upload = PendingUpload;
+                PendingUpload = null;
+                WaitingForUploadConfirm = false;
+                RequestXferPacket request = (RequestXferPacket)packet;
+
+                upload.XferID = request.XferID.ID;
+                upload.Type = (AssetType)request.XferID.VFileType;
+
+                UUID transferID = new UUID(upload.XferID);
+                Transfers[transferID] = upload;
+
+                // Send the first packet containing actual asset data
+                SendNextUploadPacket(upload);
+            }
+        }
+
+        private void ConfirmXferPacketHandler(Packet packet, Simulator simulator)
+        {
+            ConfirmXferPacketPacket confirm = (ConfirmXferPacketPacket)packet;
+
+            // Building a new UUID every time an ACK is received for an upload is a horrible
+            // thing, but this whole Xfer system is horrible
+            UUID transferID = new UUID(confirm.XferID.ID);
+            Transfer transfer;
+            AssetUpload upload = null;
+
+            if (Transfers.TryGetValue(transferID, out transfer))
+            {
+                upload = (AssetUpload)transfer;
+
+                //Client.DebugLog(String.Format("ACK for upload {0} of asset type {1} ({2}/{3})",
+                //    upload.AssetID.ToString(), upload.Type, upload.Transferred, upload.Size));
+
+                if (OnUploadProgress != null)
+                {
+                    try { OnUploadProgress(upload); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+
+                if (upload.Transferred < upload.Size)
+                    SendNextUploadPacket(upload);
+            }
+        }
+
+        private void AssetUploadCompleteHandler(Packet packet, Simulator simulator)
+        {
+            AssetUploadCompletePacket complete = (AssetUploadCompletePacket)packet;
+
+            // If we uploaded an asset in a single packet, RequestXferHandler()
+            // will never be called so we need to set this here as well
+            WaitingForUploadConfirm = false;
+
+            if (OnAssetUploaded != null)
+            {
+                bool found = false;
+                KeyValuePair<UUID, Transfer> foundTransfer = new KeyValuePair<UUID, Transfer>();
+
+                // Xfer system sucks really really bad. Where is the damn XferID?
+                lock (Transfers)
+                {
+                    foreach (KeyValuePair<UUID, Transfer> transfer in Transfers)
+                    {
+                        if (transfer.Value.GetType() == typeof(AssetUpload))
+                        {
+                            AssetUpload upload = (AssetUpload)transfer.Value;
+
+                            if ((upload).AssetID == complete.AssetBlock.UUID)
+                            {
+                                found = true;
+                                foundTransfer = transfer;
+                                upload.Success = complete.AssetBlock.Success;
+                                upload.Type = (AssetType)complete.AssetBlock.Type;
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                if (found)
+                {
+                    lock (Transfers) Transfers.Remove(foundTransfer.Key);
+
+                    try { OnAssetUploaded((AssetUpload)foundTransfer.Value); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+                else
+                {
+                    Logger.Log(String.Format(
+                        "Got an AssetUploadComplete on an unrecognized asset, AssetID: {0}, Type: {1}, Success: {2}",
+                        complete.AssetBlock.UUID, (AssetType)complete.AssetBlock.Type, complete.AssetBlock.Success),
+                        Helpers.LogLevel.Warning);
+                }
+            }
+        }
+
+        private void SendXferPacketHandler(Packet packet, Simulator simulator)
+        {
+            SendXferPacketPacket xfer = (SendXferPacketPacket)packet;
+
+            // Lame ulong to UUID conversion, please go away Xfer system
+            UUID transferID = new UUID(xfer.XferID.ID);
+            Transfer transfer;
+            XferDownload download = null;
+
+            if (Transfers.TryGetValue(transferID, out transfer))
+            {
+                download = (XferDownload)transfer;
+
+                // Apply a mask to get rid of the "end of transfer" bit
+                uint packetNum = xfer.XferID.Packet & 0x0FFFFFFF;
+
+                // Check for out of order packets, possibly indicating a resend
+                if (packetNum != download.PacketNum)
+                {
+                    if (packetNum == download.PacketNum - 1)
+                    {
+                        Logger.DebugLog("Resending Xfer download confirmation for packet " + packetNum, Client);
+                        SendConfirmXferPacket(download.XferID, packetNum);
+                    }
+                    else
+                    {
+                        Logger.Log("Out of order Xfer packet in a download, got " + packetNum + " expecting " + download.PacketNum,
+                            Helpers.LogLevel.Warning, Client);
+                        // Re-confirm the last packet we actually received
+                        SendConfirmXferPacket(download.XferID, download.PacketNum - 1);
+                    }
+
+                    return;
+                }
+
+                if (packetNum == 0)
+                {
+                    // This is the first packet received in the download, the first four bytes are a size integer
+                    // in little endian ordering
+                    byte[] bytes = xfer.DataPacket.Data;
+                    download.Size = (bytes[0] + (bytes[1] << 8) + (bytes[2] << 16) + (bytes[3] << 24));
+                    download.AssetData = new byte[download.Size];
+
+                    Logger.DebugLog("Received first packet in an Xfer download of size " + download.Size);
+
+                    Buffer.BlockCopy(xfer.DataPacket.Data, 4, download.AssetData, 0, xfer.DataPacket.Data.Length - 4);
+                    download.Transferred += xfer.DataPacket.Data.Length - 4;
+                }
+                else
+                {
+                    Buffer.BlockCopy(xfer.DataPacket.Data, 0, download.AssetData, 1000 * (int)packetNum, xfer.DataPacket.Data.Length);
+                    download.Transferred += xfer.DataPacket.Data.Length;
+                }
+
+                // Increment the packet number to the packet we are expecting next
+                download.PacketNum++;
+
+                // Confirm receiving this packet
+                SendConfirmXferPacket(download.XferID, packetNum);
+
+                if ((xfer.XferID.Packet & 0x80000000) != 0)
+                {
+                    // This is the last packet in the transfer
+                    if (!String.IsNullOrEmpty(download.Filename))
+                        Logger.DebugLog("Xfer download for asset " + download.Filename + " completed", Client);
+                    else
+                        Logger.DebugLog("Xfer download for asset " + download.VFileID.ToString() + " completed", Client);
+
+                    download.Success = true;
+                    lock (Transfers) Transfers.Remove(download.ID);
+
+                    if (OnXferReceived != null)
+                    {
+                        try { OnXferReceived(download); }
+                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                    }
+                }
+            }
+        }
+
+        #endregion Xfer Callbacks
+
+        #region Image Callbacks
+
+        /// <summary>
+        /// Handles the Image Data packet which includes the ID and Size of the image,
+        /// along with the first block of data for the image. If the image is small enough
+        /// there will be no additional packets
+        /// </summary>
+        private void ImageDataHandler(Packet packet, Simulator simulator)
+        {
+            ImageDataPacket data = (ImageDataPacket)packet;
+            ImageDownload transfer = null;
+
+            Logger.DebugLog(String.Format("ImageData: Size={0}, Packets={1}", data.ImageID.Size, data.ImageID.Packets));
+
+            lock (Transfers)
+            {
+                if (Transfers.ContainsKey(data.ImageID.ID))
+                {
+                    transfer = (ImageDownload)Transfers[data.ImageID.ID];
+
+                    // Don't set header information if we have already
+                    // received it (due to re-request)
+                    if (transfer.Size == 0)
+                    {
+                        //Client.DebugLog("Received first " + data.ImageData.Data.Length + " bytes for image " +
+                        //    data.ImageID.ID.ToString());
+
+                        if (OnImageReceiveProgress != null)
+                        {
+                            try { OnImageReceiveProgress(data.ImageID.ID, 0, data.ImageData.Data.Length, transfer.Size); }
+                            catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                        }
+
+                        transfer.Codec = (ImageCodec)data.ImageID.Codec;
+                        transfer.PacketCount = data.ImageID.Packets;
+                        transfer.Size = (int)data.ImageID.Size;
+                        transfer.AssetData = new byte[transfer.Size];
+                        transfer.AssetType = AssetType.Texture;
+                        transfer.PacketsSeen = new SortedList<ushort, ushort>();
+                        Buffer.BlockCopy(data.ImageData.Data, 0, transfer.AssetData, 0, data.ImageData.Data.Length);
+                        transfer.InitialDataSize = data.ImageData.Data.Length;
+                        transfer.Transferred += data.ImageData.Data.Length;
+			            
+                        // Check if we downloaded the full image
+                        if (transfer.Transferred >= transfer.Size)
+                        {
+                            Transfers.Remove(transfer.ID);
+                            transfer.Success = true;
+                            Cache.SaveImageToCache(transfer.ID, transfer.AssetData);
+                        }
+                    }
+                }
+            }
+
+            if (transfer != null)
+            {
+                transfer.HeaderReceivedEvent.Set();
+
+                if (OnImageReceived != null && transfer.Transferred >= transfer.Size)
+                {
+                    AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
+
+                    try { OnImageReceived(transfer, asset); }
+                    catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Handles the remaining Image data that did not fit in the initial ImageData packet
+        /// </summary>
+        private void ImagePacketHandler(Packet packet, Simulator simulator)
+        {
+            ImagePacketPacket image = (ImagePacketPacket)packet;
+            ImageDownload transfer = null;
+
+            lock (Transfers)
+            {
+                if (Transfers.ContainsKey(image.ImageID.ID))
+                {
+                    transfer = (ImageDownload)Transfers[image.ImageID.ID];
+
+                    if (transfer.Size == 0)
+                    {
+                        // We haven't received the header yet, block until it's received or times out
+                        transfer.HeaderReceivedEvent.WaitOne(1000 * 5, false);
+
+                        if (transfer.Size == 0)
+                        {
+                            Logger.Log("Timed out while waiting for the image header to download for " +
+                                transfer.ID.ToString(), Helpers.LogLevel.Warning, Client);
+
+                            transfer.Success = false;
+                            Transfers.Remove(transfer.ID);
+                            goto Callback;
+                        }
+                    }
+
+                    // The header is downloaded, we can insert this data in to the proper position
+                    // Only insert if we haven't seen this packet before
+                    lock (transfer.PacketsSeen)
+                    {
+                        if (!transfer.PacketsSeen.ContainsKey(image.ImageID.Packet))
+                        {
+                            transfer.PacketsSeen[image.ImageID.Packet] = image.ImageID.Packet;
+                            Buffer.BlockCopy(image.ImageData.Data, 0, transfer.AssetData,
+                                transfer.InitialDataSize + (1000 * (image.ImageID.Packet - 1)),
+                                image.ImageData.Data.Length);
+                            transfer.Transferred += image.ImageData.Data.Length;
+                        }
+                    }
+
+                    //Client.DebugLog("Received " + image.ImageData.Data.Length + "/" + transfer.Transferred +
+                    //    "/" + transfer.Size + " bytes for image " + image.ImageID.ID.ToString());
+
+                    transfer.TimeSinceLastPacket = 0;
+                    
+                    if (OnImageReceiveProgress != null)
+                    {
+                        try { OnImageReceiveProgress(image.ImageID.ID, image.ImageID.Packet, transfer.Transferred, transfer.Size); }
+                        catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+                    }
+
+                    // Check if we downloaded the full image
+                    if (transfer.Transferred >= transfer.Size)
+                    {
+                        Cache.SaveImageToCache(transfer.ID, transfer.AssetData);
+                        transfer.Success = true;
+                        Transfers.Remove(transfer.ID);
+                    }
+                }
+            }
+
+        Callback:
+
+            if (transfer != null && OnImageReceived != null && (transfer.Transferred >= transfer.Size || transfer.Size == 0))
+            {
+                AssetTexture asset = new AssetTexture(transfer.ID, transfer.AssetData);
+
+                try { OnImageReceived(transfer, asset); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+            }
+        }
+
+        /// <summary>
+        /// The requested image does not exist on the asset server
+        /// </summary>
+        private void ImageNotInDatabaseHandler(Packet packet, Simulator simulator)
+        {
+            ImageNotInDatabasePacket notin = (ImageNotInDatabasePacket)packet;
+            ImageDownload transfer = null;
+
+            lock (Transfers)
+            {
+                if (Transfers.ContainsKey(notin.ImageID.ID))
+                {
+                    transfer = (ImageDownload)Transfers[notin.ImageID.ID];
+                    transfer.NotFound = true;
+                    Transfers.Remove(transfer.ID);
+                }
+            }
+
+            // Fire the event with our transfer that contains Success = false;
+            if (transfer != null && OnImageReceived != null)
+            {
+                try { OnImageReceived(transfer, null); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+            }
+        }
+
+        #endregion Image Callbacks
+    }
+}
Index: GroupManager.cs
===================================================================
--- GroupManager.cs	(revision 2399)
+++ GroupManager.cs	(working copy)
@@ -1124,6 +1124,21 @@
             Client.Network.SendPacket(p);
         }
 
+        /// <summary>Set preferences for recieving group notices and listing group in prfile</summary>
+        /// <param name="groupID">The group to modify user preference on</param>
+        /// <param name="rcv_notices">Weather to recieve group notices from this group</param>
+        /// <param name="show_in_profile">Weather to list this group in your profile</param>        
+        public void setUserGroupFlags(UUID groupID, bool rcv_notices, bool show_in_profile)
+        {
+            SetGroupAcceptNoticesPacket p = new SetGroupAcceptNoticesPacket();
+            p.AgentData.AgentID = Client.Self.AgentID;
+            p.AgentData.SessionID = Client.Self.SessionID;
+            p.Data.GroupID = groupID;
+            p.Data.AcceptNotices = rcv_notices;
+            p.NewData.ListInProfile = show_in_profile;
+            Client.Network.SendPacket(p);
+        }
+
         #region Packet Handlers
 
         private void GroupDataHandler(Packet packet, Simulator simulator)
@@ -1227,8 +1242,6 @@
                 // If nothing is registered to receive this RequestID drop the data
                 if (GroupMembersRequests.Contains(members.GroupData.RequestID))
                 {
-                    GroupMembersRequests.Remove(members.GroupData.RequestID);
-
                     lock (GroupMembersCaches)
                     {
                         if (!GroupMembersCaches.TryGetValue(members.GroupData.RequestID, out groupMemberCache))
@@ -1251,6 +1264,10 @@
                             groupMemberCache[block.AgentID] = groupMember;
                         }
                     }
+
+
+                    if (groupMemberCache.Count >= members.GroupData.MemberCount)
+                        GroupMembersRequests.Remove(members.GroupData.RequestID);
                 }
             }
 
Index: Inventory.cs
===================================================================
--- Inventory.cs	(revision 2399)
+++ Inventory.cs	(working copy)
@@ -1,384 +1,384 @@
-/*
- * Copyright (c) 2007-2008, openmetaverse.org
- * All rights reserved.
- *
- * - Redistribution and use in source and binary forms, with or without 
- *   modification, are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, this
- *   list of conditions and the following disclaimer.
- * - Neither the name of the openmetaverse.org nor the names 
- *   of its contributors may be used to endorse or promote products derived from
- *   this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-using System;
-using System.Collections.Generic;
-
-namespace OpenMetaverse
-{
-    /// <summary>
-    /// Exception class to identify inventory exceptions
-    /// </summary>
-    public class InventoryException : Exception
-    {
-        public InventoryException(string message)
-            : base(message) { }
-    }
-
-    /// <summary>
-    /// Responsible for maintaining inventory structure. Inventory constructs nodes
-    /// and manages node children as is necessary to maintain a coherant hirarchy.
-    /// Other classes should not manipulate or create InventoryNodes explicitly. When
-    /// A node's parent changes (when a folder is moved, for example) simply pass
-    /// Inventory the updated InventoryFolder and it will make the appropriate changes
-    /// to its internal representation.
-    /// </summary>
-    public class Inventory
-    {
-        /// <summary>
-        /// Delegate to use for the OnInventoryObjectUpdated event.
-        /// </summary>
-        /// <param name="oldObject">The state of the InventoryObject before the update occured.</param>
-        /// <param name="newObject">The state of the InventoryObject after the update occured.</param>
-        public delegate void InventoryObjectUpdated(InventoryBase oldObject, InventoryBase newObject);
-        /// <summary>
-        /// Delegate to use for the OnInventoryObjectRemoved event.
-        /// </summary>
-        /// <param name="obj">The InventoryObject that was removed.</param>
-        public delegate void InventoryObjectRemoved(InventoryBase obj);
-        /// <summary>
-        /// Delegate to use for the OnInventoryObjectUpdated event.
-        /// </summary>
-        /// <param name="obj">The InventoryObject that has been stored.</param>
-        public delegate void InventoryObjectAdded(InventoryBase obj);
-
-        /// <summary>
-        /// Called when an InventoryObject's state is changed.
-        /// </summary>
-        public event InventoryObjectUpdated OnInventoryObjectUpdated;
-        /// <summary>
-        /// Called when an item or folder is removed from inventory.
-        /// </summary>
-        public event InventoryObjectRemoved OnInventoryObjectRemoved;
-        /// <summary>
-        /// Called when an item is first added to the local inventory store.
-        /// This will occur most frequently when we're initially downloading
-        /// the inventory from the server.
-        /// 
-        /// This will also fire when another avatar or object offers us inventory
-        /// </summary>
-        public event InventoryObjectAdded OnInventoryObjectAdded;
-
-        /// <summary>
-        /// The root folder of this avatars inventory
-        /// </summary>
-        public InventoryFolder RootFolder
-        {
-            get { return RootNode.Data as InventoryFolder; }
-            set 
-            {
-                UpdateNodeFor(value);
-                _RootNode = Items[value.UUID];
-            }
-        }
-
-        /// <summary>
-        /// The default shared library folder
-        /// </summary>
-        public InventoryFolder LibraryFolder
-        {
-            get { return LibraryRootNode.Data as InventoryFolder; }
-            set
-            {
-                UpdateNodeFor(value);
-                _LibraryRootNode = Items[value.UUID];
-            }
-        }
-
-        private InventoryNode _LibraryRootNode;
-        private InventoryNode _RootNode;
-        
-        /// <summary>
-        /// The root node of the avatars inventory
-        /// </summary>
-        public InventoryNode RootNode
-        {
-            get
-            {
-                if (_RootNode == null)
-                    throw new InventoryException("Root node unknown. Are you completely logged in?");
-                return _RootNode;
-            }
-        }
-
-        /// <summary>
-        /// The root node of the default shared library
-        /// </summary>
-        public InventoryNode LibraryRootNode
-        {
-            get
-            {
-                if (_LibraryRootNode == null)
-                    throw new InventoryException("Library Root node unknown. Are you completely logged in?");
-                return _LibraryRootNode;
-            }
-        }
-
-        public UUID Owner {
-            get { return _Owner; }
-        }
-
-        private UUID _Owner;
-
-        private GridClient Client;
-        //private InventoryManager Manager;
-        private Dictionary<UUID, InventoryNode> Items = new Dictionary<UUID, InventoryNode>();
-
-        public Inventory(GridClient client, InventoryManager manager)
-            : this(client, manager, client.Self.AgentID) { }
-
-        public Inventory(GridClient client, InventoryManager manager, UUID owner)
-        {
-            Client = client;
-            //Manager = manager;
-            _Owner = owner;
-            if (owner == UUID.Zero)
-                Logger.Log("Inventory owned by nobody!", Helpers.LogLevel.Warning, Client);
-            Items = new Dictionary<UUID, InventoryNode>();
-        }
-
-        public List<InventoryBase> GetContents(InventoryFolder folder)
-        {
-            return GetContents(folder.UUID);
-        }
-
-        /// <summary>
-        /// Returns the contents of the specified folder
-        /// </summary>
-        /// <param name="folder">A folder's UUID</param>
-        /// <returns>The contents of the folder corresponding to <code>folder</code></returns>
-        /// <exception cref="InventoryException">When <code>folder</code> does not exist in the inventory</exception>
-        public List<InventoryBase> GetContents(UUID folder)
-        {
-            InventoryNode folderNode;
-            if (!Items.TryGetValue(folder, out folderNode))
-                throw new InventoryException("Unknown folder: " + folder);
-            lock (folderNode.Nodes.SyncRoot)
-            {
-                List<InventoryBase> contents = new List<InventoryBase>(folderNode.Nodes.Count);
-                foreach (InventoryNode node in folderNode.Nodes.Values)
-                {
-                    contents.Add(node.Data);
-                }
-                return contents;
-            }
-        }
-
-        /// <summary>
-        /// Updates the state of the InventoryNode and inventory data structure that
-        /// is responsible for the InventoryObject. If the item was previously not added to inventory,
-        /// it adds the item, and updates structure accordingly. If it was, it updates the 
-        /// InventoryNode, changing the parent node if <code>item.parentUUID</code> does 
-        /// not match <code>node.Parent.Data.UUID</code>.
-        /// 
-        /// You can not set the inventory root folder using this method
-        /// </summary>
-        /// <param name="item">The InventoryObject to store</param>
-        public void UpdateNodeFor(InventoryBase item)
-        {
-            lock (Items)
-            {
-                InventoryNode itemParent = null;
-                if (item.ParentUUID != UUID.Zero && !Items.TryGetValue(item.ParentUUID, out itemParent))
-                {
-                    // OK, we have no data on the parent, let's create a fake one.
-                    InventoryFolder fakeParent = new InventoryFolder(item.ParentUUID);
-                    fakeParent.DescendentCount = 1; // Dear god, please forgive me.
-                    itemParent = new InventoryNode(fakeParent);
-                    Items[item.ParentUUID] = itemParent;
-                    // Unfortunately, this breaks the nice unified tree
-                    // while we're waiting for the parent's data to come in.
-                    // As soon as we get the parent, the tree repairs itself.
-                    Logger.DebugLog("Attempting to update inventory child of " +
-                        item.ParentUUID.ToString() + " when we have no local reference to that folder", Client);
-
-                    if (Client.Settings.FETCH_MISSING_INVENTORY)
-                    {
-                        // Fetch the parent
-                        List<UUID> fetchreq = new List<UUID>(1);
-                        fetchreq.Add(item.ParentUUID);
-                        //Manager.FetchInventory(fetchreq); // we cant fetch folder data! :-O
-                    }
-                }
-
-                InventoryNode itemNode;
-                if (Items.TryGetValue(item.UUID, out itemNode)) // We're updating.
-                {
-                    InventoryNode oldParent = itemNode.Parent;
-                    // Handle parent change
-                    if (oldParent == null || itemParent == null || itemParent.Data.UUID != oldParent.Data.UUID)
-                    {
-                        if (oldParent != null)
-                        {
-                            lock (oldParent.Nodes.SyncRoot)
-                                oldParent.Nodes.Remove(item.UUID);
-                        }
-                        if (itemParent != null)
-                        {
-                            lock (itemParent.Nodes.SyncRoot)
-                                itemParent.Nodes[item.UUID] = itemNode;
-                        }
-                    }
-
-                    itemNode.Parent = itemParent;
-
-                    if (item != itemNode.Data)
-                        FireOnInventoryObjectUpdated(itemNode.Data, item);
-
-                    itemNode.Data = item;
-                }
-                else // We're adding.
-                {
-                    itemNode = new InventoryNode(item, itemParent);
-                    Items.Add(item.UUID, itemNode);
-                    FireOnInventoryObjectAdded(item);
-                }
-            }
-        }
-
-        public InventoryNode GetNodeFor(UUID uuid)
-        {
-            return Items[uuid];
-        }
-
-        /// <summary>
-        /// Removes the InventoryObject and all related node data from Inventory.
-        /// </summary>
-        /// <param name="item">The InventoryObject to remove.</param>
-        public void RemoveNodeFor(InventoryBase item)
-        {
-            lock (Items)
-            {
-                InventoryNode node;
-                if (Items.TryGetValue(item.UUID, out node))
-                {
-                    if (node.Parent != null)
-                        lock (node.Parent.Nodes.SyncRoot)
-                            node.Parent.Nodes.Remove(item.UUID);
-                    Items.Remove(item.UUID);
-                    FireOnInventoryObjectRemoved(item);
-                }
-
-                // In case there's a new parent:
-                InventoryNode newParent;
-                if (Items.TryGetValue(item.ParentUUID, out newParent))
-                {
-                    lock (newParent.Nodes.SyncRoot)
-                        newParent.Nodes.Remove(item.UUID);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Used to find out if Inventory contains the InventoryObject
-        /// specified by <code>uuid</code>.
-        /// </summary>
-        /// <param name="uuid">The UUID to check.</param>
-        /// <returns>true if inventory contains uuid, false otherwise</returns>
-        public bool Contains(UUID uuid)
-        {
-            return Items.ContainsKey(uuid);
-        }
-
-        public bool Contains(InventoryBase obj)
-        {
-            return Contains(obj.UUID);
-        }
-
-        #region Operators
-
-        /// <summary>
-        /// By using the bracket operator on this class, the program can get the 
-        /// InventoryObject designated by the specified uuid. If the value for the corresponding
-        /// UUID is null, the call is equivelant to a call to <code>RemoveNodeFor(this[uuid])</code>.
-        /// If the value is non-null, it is equivelant to a call to <code>UpdateNodeFor(value)</code>,
-        /// the uuid parameter is ignored.
-        /// </summary>
-        /// <param name="uuid">The UUID of the InventoryObject to get or set, ignored if set to non-null value.</param>
-        /// <returns>The InventoryObject corresponding to <code>uuid</code>.</returns>
-        public InventoryBase this[UUID uuid]
-        {
-            get
-            {
-                InventoryNode node = Items[uuid];
-                return node.Data;
-            }
-            set
-            {
-                if (value != null)
-                {
-                    // Log a warning if there is a UUID mismatch, this will cause problems
-                    if (value.UUID != uuid)
-                        Logger.Log("Inventory[uuid]: uuid " + uuid.ToString() + " is not equal to value.UUID " +
-                            value.UUID.ToString(), Helpers.LogLevel.Warning, Client);
-
-                    UpdateNodeFor(value);
-                }
-                else
-                {
-                    InventoryNode node;
-                    if (Items.TryGetValue(uuid, out node))
-                    {
-                        RemoveNodeFor(node.Data);
-                    }
-                }
-            }
-        }
-
-        #endregion Operators
-
-        #region Event Firing
-
-        protected void FireOnInventoryObjectUpdated(InventoryBase oldObject, InventoryBase newObject)
-        {
-            if (OnInventoryObjectUpdated != null)
-            {
-                try { OnInventoryObjectUpdated(oldObject, newObject); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-            }
-        }
-
-        protected void FireOnInventoryObjectRemoved(InventoryBase obj)
-        {
-            if (OnInventoryObjectRemoved != null)
-            {
-                try { OnInventoryObjectRemoved(obj); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-            }
-        }
-
-        protected void FireOnInventoryObjectAdded(InventoryBase obj)
-        {
-            if (OnInventoryObjectAdded != null)
-            {
-                try { OnInventoryObjectAdded(obj); }
-                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
-            }
-        }
-
-        #endregion
-    }
-}
+/*
+ * Copyright (c) 2007-2008, openmetaverse.org
+ * All rights reserved.
+ *
+ * - Redistribution and use in source and binary forms, with or without 
+ *   modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ * - Neither the name of the openmetaverse.org nor the names 
+ *   of its contributors may be used to endorse or promote products derived from
+ *   this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+using System;
+using System.Collections.Generic;
+
+namespace OpenMetaverse
+{
+    /// <summary>
+    /// Exception class to identify inventory exceptions
+    /// </summary>
+    public class InventoryException : Exception
+    {
+        public InventoryException(string message)
+            : base(message) { }
+    }
+
+    /// <summary>
+    /// Responsible for maintaining inventory structure. Inventory constructs nodes
+    /// and manages node children as is necessary to maintain a coherant hirarchy.
+    /// Other classes should not manipulate or create InventoryNodes explicitly. When
+    /// A node's parent changes (when a folder is moved, for example) simply pass
+    /// Inventory the updated InventoryFolder and it will make the appropriate changes
+    /// to its internal representation.
+    /// </summary>
+    public class Inventory
+    {
+        /// <summary>
+        /// Delegate to use for the OnInventoryObjectUpdated event.
+        /// </summary>
+        /// <param name="oldObject">The state of the InventoryObject before the update occured.</param>
+        /// <param name="newObject">The state of the InventoryObject after the update occured.</param>
+        public delegate void InventoryObjectUpdated(InventoryBase oldObject, InventoryBase newObject);
+        /// <summary>
+        /// Delegate to use for the OnInventoryObjectRemoved event.
+        /// </summary>
+        /// <param name="obj">The InventoryObject that was removed.</param>
+        public delegate void InventoryObjectRemoved(InventoryBase obj);
+        /// <summary>
+        /// Delegate to use for the OnInventoryObjectUpdated event.
+        /// </summary>
+        /// <param name="obj">The InventoryObject that has been stored.</param>
+        public delegate void InventoryObjectAdded(InventoryBase obj);
+
+        /// <summary>
+        /// Called when an InventoryObject's state is changed.
+        /// </summary>
+        public event InventoryObjectUpdated OnInventoryObjectUpdated;
+        /// <summary>
+        /// Called when an item or folder is removed from inventory.
+        /// </summary>
+        public event InventoryObjectRemoved OnInventoryObjectRemoved;
+        /// <summary>
+        /// Called when an item is first added to the local inventory store.
+        /// This will occur most frequently when we're initially downloading
+        /// the inventory from the server.
+        /// 
+        /// This will also fire when another avatar or object offers us inventory
+        /// </summary>
+        public event InventoryObjectAdded OnInventoryObjectAdded;
+
+        /// <summary>
+        /// The root folder of this avatars inventory
+        /// </summary>
+        public InventoryFolder RootFolder
+        {
+            get { return RootNode.Data as InventoryFolder; }
+            set 
+            {
+                UpdateNodeFor(value);
+                _RootNode = Items[value.UUID];
+            }
+        }
+
+        /// <summary>
+        /// The default shared library folder
+        /// </summary>
+        public InventoryFolder LibraryFolder
+        {
+            get { return LibraryRootNode.Data as InventoryFolder; }
+            set
+            {
+                UpdateNodeFor(value);
+                _LibraryRootNode = Items[value.UUID];
+            }
+        }
+
+        private InventoryNode _LibraryRootNode;
+        private InventoryNode _RootNode;
+        
+        /// <summary>
+        /// The root node of the avatars inventory
+        /// </summary>
+        public InventoryNode RootNode
+        {
+            get
+            {
+                if (_RootNode == null)
+                    throw new InventoryException("Root node unknown. Are you completely logged in?");
+                return _RootNode;
+            }
+        }
+
+        /// <summary>
+        /// The root node of the default shared library
+        /// </summary>
+        public InventoryNode LibraryRootNode
+        {
+            get
+            {
+                if (_LibraryRootNode == null)
+                    throw new InventoryException("Library Root node unknown. Are you completely logged in?");
+                return _LibraryRootNode;
+            }
+        }
+
+        public UUID Owner {
+            get { return _Owner; }
+        }
+
+        private UUID _Owner;
+
+        private GridClient Client;
+        //private InventoryManager Manager;
+        public Dictionary<UUID, InventoryNode> Items = new Dictionary<UUID, InventoryNode>();
+
+        public Inventory(GridClient client, InventoryManager manager)
+            : this(client, manager, client.Self.AgentID) { }
+
+        public Inventory(GridClient client, InventoryManager manager, UUID owner)
+        {
+            Client = client;
+            //Manager = manager;
+            _Owner = owner;
+            if (owner == UUID.Zero)
+                Logger.Log("Inventory owned by nobody!", Helpers.LogLevel.Warning, Client);
+            Items = new Dictionary<UUID, InventoryNode>();
+        }
+
+        public List<InventoryBase> GetContents(InventoryFolder folder)
+        {
+            return GetContents(folder.UUID);
+        }
+
+        /// <summary>
+        /// Returns the contents of the specified folder
+        /// </summary>
+        /// <param name="folder">A folder's UUID</param>
+        /// <returns>The contents of the folder corresponding to <code>folder</code></returns>
+        /// <exception cref="InventoryException">When <code>folder</code> does not exist in the inventory</exception>
+        public List<InventoryBase> GetContents(UUID folder)
+        {
+            InventoryNode folderNode;
+            if (!Items.TryGetValue(folder, out folderNode))
+                throw new InventoryException("Unknown folder: " + folder);
+            lock (folderNode.Nodes.SyncRoot)
+            {
+                List<InventoryBase> contents = new List<InventoryBase>(folderNode.Nodes.Count);
+                foreach (InventoryNode node in folderNode.Nodes.Values)
+                {
+                    contents.Add(node.Data);
+                }
+                return contents;
+            }
+        }
+
+        /// <summary>
+        /// Updates the state of the InventoryNode and inventory data structure that
+        /// is responsible for the InventoryObject. If the item was previously not added to inventory,
+        /// it adds the item, and updates structure accordingly. If it was, it updates the 
+        /// InventoryNode, changing the parent node if <code>item.parentUUID</code> does 
+        /// not match <code>node.Parent.Data.UUID</code>.
+        /// 
+        /// You can not set the inventory root folder using this method
+        /// </summary>
+        /// <param name="item">The InventoryObject to store</param>
+        public void UpdateNodeFor(InventoryBase item)
+        {
+            lock (Items)
+            {
+                InventoryNode itemParent = null;
+                if (item.ParentUUID != UUID.Zero && !Items.TryGetValue(item.ParentUUID, out itemParent))
+                {
+                    // OK, we have no data on the parent, let's create a fake one.
+                    InventoryFolder fakeParent = new InventoryFolder(item.ParentUUID);
+                    fakeParent.DescendentCount = 1; // Dear god, please forgive me.
+                    itemParent = new InventoryNode(fakeParent);
+                    Items[item.ParentUUID] = itemParent;
+                    // Unfortunately, this breaks the nice unified tree
+                    // while we're waiting for the parent's data to come in.
+                    // As soon as we get the parent, the tree repairs itself.
+                    Logger.DebugLog("Attempting to update inventory child of " +
+                        item.ParentUUID.ToString() + " when we have no local reference to that folder", Client);
+
+                    if (Client.Settings.FETCH_MISSING_INVENTORY)
+                    {
+                        // Fetch the parent
+                        List<UUID> fetchreq = new List<UUID>(1);
+                        fetchreq.Add(item.ParentUUID);
+                        //Manager.FetchInventory(fetchreq); // we cant fetch folder data! :-O
+                    }
+                }
+
+                InventoryNode itemNode;
+                if (Items.TryGetValue(item.UUID, out itemNode)) // We're updating.
+                {
+                    InventoryNode oldParent = itemNode.Parent;
+                    // Handle parent change
+                    if (oldParent == null || itemParent == null || itemParent.Data.UUID != oldParent.Data.UUID)
+                    {
+                        if (oldParent != null)
+                        {
+                            lock (oldParent.Nodes.SyncRoot)
+                                oldParent.Nodes.Remove(item.UUID);
+                        }
+                        if (itemParent != null)
+                        {
+                            lock (itemParent.Nodes.SyncRoot)
+                                itemParent.Nodes[item.UUID] = itemNode;
+                        }
+                    }
+
+                    itemNode.Parent = itemParent;
+
+                    if (item != itemNode.Data)
+                        FireOnInventoryObjectUpdated(itemNode.Data, item);
+
+                    itemNode.Data = item;
+                }
+                else // We're adding.
+                {
+                    itemNode = new InventoryNode(item, itemParent);
+                    Items.Add(item.UUID, itemNode);
+                    FireOnInventoryObjectAdded(item);
+                }
+            }
+        }
+
+        public InventoryNode GetNodeFor(UUID uuid)
+        {
+            return Items[uuid];
+        }
+
+        /// <summary>
+        /// Removes the InventoryObject and all related node data from Inventory.
+        /// </summary>
+        /// <param name="item">The InventoryObject to remove.</param>
+        public void RemoveNodeFor(InventoryBase item)
+        {
+            lock (Items)
+            {
+                InventoryNode node;
+                if (Items.TryGetValue(item.UUID, out node))
+                {
+                    if (node.Parent != null)
+                        lock (node.Parent.Nodes.SyncRoot)
+                            node.Parent.Nodes.Remove(item.UUID);
+                    Items.Remove(item.UUID);
+                    FireOnInventoryObjectRemoved(item);
+                }
+
+                // In case there's a new parent:
+                InventoryNode newParent;
+                if (Items.TryGetValue(item.ParentUUID, out newParent))
+                {
+                    lock (newParent.Nodes.SyncRoot)
+                        newParent.Nodes.Remove(item.UUID);
+                }
+            }
+        }
+
+        /// <summary>
+        /// Used to find out if Inventory contains the InventoryObject
+        /// specified by <code>uuid</code>.
+        /// </summary>
+        /// <param name="uuid">The UUID to check.</param>
+        /// <returns>true if inventory contains uuid, false otherwise</returns>
+        public bool Contains(UUID uuid)
+        {
+            return Items.ContainsKey(uuid);
+        }
+
+        public bool Contains(InventoryBase obj)
+        {
+            return Contains(obj.UUID);
+        }
+
+        #region Operators
+
+        /// <summary>
+        /// By using the bracket operator on this class, the program can get the 
+        /// InventoryObject designated by the specified uuid. If the value for the corresponding
+        /// UUID is null, the call is equivelant to a call to <code>RemoveNodeFor(this[uuid])</code>.
+        /// If the value is non-null, it is equivelant to a call to <code>UpdateNodeFor(value)</code>,
+        /// the uuid parameter is ignored.
+        /// </summary>
+        /// <param name="uuid">The UUID of the InventoryObject to get or set, ignored if set to non-null value.</param>
+        /// <returns>The InventoryObject corresponding to <code>uuid</code>.</returns>
+        public InventoryBase this[UUID uuid]
+        {
+            get
+            {
+                InventoryNode node = Items[uuid];
+                return node.Data;
+            }
+            set
+            {
+                if (value != null)
+                {
+                    // Log a warning if there is a UUID mismatch, this will cause problems
+                    if (value.UUID != uuid)
+                        Logger.Log("Inventory[uuid]: uuid " + uuid.ToString() + " is not equal to value.UUID " +
+                            value.UUID.ToString(), Helpers.LogLevel.Warning, Client);
+
+                    UpdateNodeFor(value);
+                }
+                else
+                {
+                    InventoryNode node;
+                    if (Items.TryGetValue(uuid, out node))
+                    {
+                        RemoveNodeFor(node.Data);
+                    }
+                }
+            }
+        }
+
+        #endregion Operators
+
+        #region Event Firing
+
+        protected void FireOnInventoryObjectUpdated(InventoryBase oldObject, InventoryBase newObject)
+        {
+            if (OnInventoryObjectUpdated != null)
+            {
+                try { OnInventoryObjectUpdated(oldObject, newObject); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+            }
+        }
+
+        protected void FireOnInventoryObjectRemoved(InventoryBase obj)
+        {
+            if (OnInventoryObjectRemoved != null)
+            {
+                try { OnInventoryObjectRemoved(obj); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+            }
+        }
+
+        protected void FireOnInventoryObjectAdded(InventoryBase obj)
+        {
+            if (OnInventoryObjectAdded != null)
+            {
+                try { OnInventoryObjectAdded(obj); }
+                catch (Exception e) { Logger.Log(e.Message, Helpers.LogLevel.Error, Client, e); }
+            }
+        }
+
+        #endregion
+    }
+}
Index: InventoryManager.cs
===================================================================
--- InventoryManager.cs	(revision 2399)
+++ InventoryManager.cs	(working copy)
@@ -787,7 +787,7 @@
         #endregion Events
 
         private GridClient _Client;
-        private Inventory _Store;
+        public Inventory _Store;
         //private Random _RandNumbers = new Random();
         private object _CallbacksLock = new object();
         private uint _CallbackPos;
@@ -1836,7 +1836,8 @@
         /// <param name="notecardID"></param>
         /// <param name="folderID"></param>
         /// <param name="itemID"></param>
-        public void RequestCopyItemFromNotecard(UUID objectID, UUID notecardID, UUID folderID, UUID itemID)
+        /// <param name="callbackD"></param>
+        public void RequestCopyItemFromNotecard(UUID objectID, UUID notecardID, UUID folderID, UUID itemID,ItemCopiedCallback callback)
         {
             CopyInventoryFromNotecardPacket copy = new CopyInventoryFromNotecardPacket();
             copy.AgentData.AgentID = _Client.Self.AgentID;
@@ -1850,6 +1851,8 @@
             copy.InventoryData[0].FolderID = folderID;
             copy.InventoryData[0].ItemID = itemID;
 
+			_ItemCopiedCallbacks[0] = callback;
+
             _Client.Network.SendPacket(copy);
         }
 
Index: Settings.cs
===================================================================
--- Settings.cs	(revision 2399)
+++ Settings.cs	(working copy)
@@ -47,9 +47,6 @@
         /// <summary>Beta grid login server</summary>
         public const string ADITI_LOGIN_SERVER = "https://login.aditi.lindenlab.com/cgi-bin/login.cgi";
 
-        /// <summary>The relative directory where external resources are kept</summary>
-        public const string RESOURCE_DIR = "openmetaverse_data";
-
         /// <summary>Login server to connect to</summary>
         public string LOGIN_SERVER = AGNI_LOGIN_SERVER;
 
@@ -263,8 +260,11 @@
         /// </summary>
         public bool USE_TEXTURE_CACHE = false;
 
+        /// <summary>The relative directory where external resources are kept</summary>
+        public static string RESOURCE_DIR = "openmetaverse_data";
+
         /// <summary>Path to store cached texture data</summary>
-        public string TEXTURE_CACHE_DIR = RESOURCE_DIR + "/cache";
+        public string TEXTURE_CACHE_DIR =  "openmetaverse_data/cache";
 
         /// <summary>Maximum size cached files are allowed to take on disk (bytes)</summary>
         public long TEXTURE_CACHE_MAX_SIZE = 1024 * 1024 * 1024; // 1GB
@@ -333,5 +333,10 @@
         }
 
         #endregion
+
+	public void setresourcedir(string dir)
+	{
+		RESOURCE_DIR=dir;
+	}
     }
 }
Index: Simulator.cs
===================================================================
--- Simulator.cs	(revision 2399)
+++ Simulator.cs	(working copy)
@@ -866,8 +866,8 @@
             // Check if this packet came from the server we expected it to come from
             if (!remoteEndPoint.Address.Equals(((IPEndPoint)buffer.RemoteEndPoint).Address))
             {
-                Logger.Log("Received " + buffer.DataLength + " bytes of data from unrecognized source " +
-                    ((IPEndPoint)buffer.RemoteEndPoint).ToString(), Helpers.LogLevel.Warning, Client);
+                //Logger.Log("Received " + buffer.DataLength + " bytes of data from unrecognized source " +
+                //    ((IPEndPoint)buffer.RemoteEndPoint).ToString(), Helpers.LogLevel.Warning, Client);
                 return;
             }
 
